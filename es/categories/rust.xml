<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Willy's blog (Publicaciones sobre rust)</title><link>https://woile.dev/</link><description></description><atom:link href="https://woile.dev/es/categories/rust.xml" rel="self" type="application/rss+xml"></atom:link><language>es</language><copyright>Contents ¬© 2023 &lt;a href="mailto:santiwilly@gmail.com"&gt;Woile&lt;/a&gt; </copyright><lastBuildDate>Sat, 14 Jan 2023 14:40:12 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Nix journey part 2: replacing apt and brew</title><link>https://woile.dev/es/posts/nix-journey-part-2-replacing-apt-and-brew/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;Even if I still cannot do much with &lt;a href="https://nixos.org/"&gt;nix&lt;/a&gt;, it still provide more advantages over other package managers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multi-platform (mac, linux, etc.)&lt;/li&gt;
&lt;li&gt;Supports side-by-side installation of multiple versions of a package&lt;/li&gt;
&lt;li&gt;Makes it trivial to share development and build environments&lt;/li&gt;
&lt;li&gt;Nix ensures that installing or upgrading one package cannot break other packages&lt;/li&gt;
&lt;li&gt;It has the biggest database of packages (over 80.000 packages)&lt;/li&gt;
&lt;li&gt;I can run other people's commands, for example if I clone a repo and it says "run this nix command to have a development environment", then it doesn't matter if I don't know, I have already started using it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A common situation I often have between linux and mac is running &lt;code&gt;grip&lt;/code&gt; or &lt;code&gt;sed&lt;/code&gt;.
On linux, they are called GNU &lt;code&gt;grep&lt;/code&gt; or GNU &lt;code&gt;sed&lt;/code&gt;, and they are not the same as in mac (freebsd versin), they may not accept the same parameters.
We are gonna see how can to avoid this using nix. And even without using complicated features, it can make your CI system more reproducible.&lt;/p&gt;
&lt;p&gt;Remember &lt;code&gt;nix&lt;/code&gt; is 3 things at the same time: an OS, a package manager and a language.&lt;/p&gt;
&lt;p&gt;This post is about the &lt;strong&gt;package manager&lt;/strong&gt;. I don't have much interest in the language, but more and more I think I'll have to learn it.&lt;/p&gt;
&lt;p&gt;Let's start by acknowledging a source of confusion:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There is an old interface with counterintuitive commands&lt;/strong&gt; (&lt;code&gt;nix-env -iA ...&lt;/code&gt;, &lt;code&gt;nix-shell -p ...&lt;/code&gt;), which I found hard to remember, and I don't get why they "commands" start with a dash (&lt;code&gt;-&lt;/code&gt;). I'm used to cli's doing &lt;code&gt;cli &amp;lt;command&amp;gt; [--options]&lt;/code&gt;. Nowadays there's a new cli called just &lt;code&gt;nix&lt;/code&gt;, let's see if we can do everything with it.&lt;/p&gt;
&lt;p&gt;And make sure you have &lt;a href="https://nixos.org/download.html"&gt;installed Nix: the package manager&lt;/a&gt; in your system. The installation is straightforward. I was personally blocked, because at some point in my dotfiles I was hardcoding the &lt;code&gt;PATH&lt;/code&gt;, making nix never appear ü§¶‚Äç‚ôÇÔ∏è.&lt;/p&gt;
&lt;p&gt;And &lt;a href="https://nixos.wiki/wiki/Flakes#Enable_flakes"&gt;enable flakes&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Installing packages&lt;/h3&gt;
&lt;p&gt;Install a package like on &lt;code&gt;brew&lt;/code&gt; or &lt;code&gt;apt&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile install nixpkgs#htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See also the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile-install.html"&gt;profile install command reference&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the old version of nix, we would run:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix-env -iA nixpkgs.htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nix forces us to specify a "repository" (or "namespace") when installing a package (&lt;code&gt;nixpkgs&lt;/code&gt;), which could be different, like github. And I think this is a good thing. From my understanding, nix doesn't care where the package is, because each package has a lock file, tracking all the dependencies. Okay, it could be a problem if one of the "repositories" is down, but using &lt;code&gt;nixpkgs&lt;/code&gt; mainly and github for niche packages should be fine.&lt;/p&gt;
&lt;h4&gt;What are profiles?&lt;/h4&gt;
&lt;p&gt;Disclaimer: I may be wrong on this, I'm starting to understand it.&lt;/p&gt;
&lt;p&gt;The way to see &lt;code&gt;profiles&lt;/code&gt; is like "your user's packages". &lt;code&gt;nix profile&lt;/code&gt; links packages to your &lt;code&gt;~/.nix-profile/&lt;/code&gt;. You can specify other's profiles by using the flag &lt;code&gt;-p&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can find more in the &lt;a href="https://nixos.org/manual/nix/stable/package-management/profiles.html"&gt;package-management section of the manual&lt;/a&gt; and &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile.html"&gt;the profile command reference&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Searching packages&lt;/h3&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix search nixpkgs#htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-search.html"&gt;search command reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We see again &lt;code&gt;nixpkgs&lt;/code&gt;, because we have to let nix know from where, and then what we are looking for (&lt;code&gt;htop&lt;/code&gt; in this case). To remember the word, I split it like this: &lt;code&gt;nix-p-k-gs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, I've made a flake package, hosted on github, and you can search what is offering, by specifying the "repository" only (no &lt;code&gt;#&lt;/code&gt;):&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix search 'github:woile/wpa_passphrase_rs'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also search packages on &lt;a href="https://search.nixos.org/packages?channel=22.11&amp;amp;show=htop&amp;amp;from=0&amp;amp;size=50&amp;amp;sort=relevance&amp;amp;type=packages&amp;amp;query=htop"&gt;nix search index&lt;/a&gt;, but the commands shown are for the old nix interface, using &lt;code&gt;nix-env&lt;/code&gt; or &lt;code&gt;nix-shell&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also, you can provide a regex like &lt;code&gt;firefox|chrome&lt;/code&gt;, run &lt;code&gt;nix search --help&lt;/code&gt; for more examples.&lt;/p&gt;
&lt;h3&gt;Removing packages&lt;/h3&gt;
&lt;p&gt;Now this is a bit tricky, to remove you cannot type &lt;code&gt;htop&lt;/code&gt;, you have to specify which dependency you want to clean. I think this is because one of your packages may depend on the version of another package, and if you also installed another version of the same package, then if you remove both, the original program that depends on one of them may break.&lt;/p&gt;
&lt;p&gt;The solution to this is to list the installed packages in your profile, and then remove by position of said program.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile list&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile remove 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile-remove.html"&gt;profile remove command reference&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Open a package on a shell&lt;/h3&gt;
&lt;p&gt;This can be useful to test in isolation without installing a package in your profile.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix shell nixpkgs#htop nixpkgs#gnused nixpkgs#youtube-dl

sed --help
htop --help
youtube-dl --version
CTRL+D # exit&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Nix package manager (npt)&lt;/h3&gt;
&lt;p&gt;Because I'm not used to most of the seen commands, I built a thin abstraction on top called &lt;a href="https://github.com/woile/npt"&gt;npt&lt;/a&gt;. Which aims to be a humble succesor to &lt;code&gt;apt&lt;/code&gt;. It also requires less characters to use it.&lt;/p&gt;
&lt;p&gt;The installation, as we've seen before, can be done by running:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile install 'github:woile/npt#npt'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then run &lt;code&gt;npt --help&lt;/code&gt; and check the commands, I hope it helps the transition to nix.&lt;/p&gt;
&lt;p&gt;Now you can install packages by doing:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;npt install htop github:woile/wpa_passphrase_rs#wpa_passphrase
# or npt i&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's still a work in progress, but a good start. I want to add to it the ability to show the executed nix commands, as a way to learn.&lt;/p&gt;
&lt;h3&gt;Reproducible scripts&lt;/h3&gt;
&lt;p&gt;Remember when I said even if you don't know much, someone else might, and having nix helps for this? and remember when I talked about my problems with &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Turns out nix can help in both of these situations, someone can write a reproducible shell script which you would execute, even without knowing much, it would work.&lt;/p&gt;
&lt;p&gt;A minor problem is that we cannot use flakes yet, meaning we cannot run &lt;code&gt;nix shell&lt;/code&gt; and instead, we have to rely on &lt;code&gt;nix-shell&lt;/code&gt;. But it's coming, see &lt;a href="https://github.com/NixOS/nix/pull/5189"&gt;#5189&lt;/a&gt;, &lt;a href="https://github.com/NixOS/nix/issues/4715"&gt;#4715&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the meantime, let's try to solve the issue with what we have.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;touch gnu-example.sh
chmod +x gnu-example.sh
vim gnu-example.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And paste the content of this script:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;#! /usr/bin/env nix-shell
#! nix-shell gnused gnugrep

grep -V
sed --version&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If run &lt;code&gt;./gnu-example.sh&lt;/code&gt;, it would work both on linux, mac and probably also on freebsd.&lt;/p&gt;
&lt;p&gt;Take a look at this other example, you can install a specific version of python and even dependencies.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-python"&gt;#! /usr/bin/env nix-shell
#! nix-shell --pure -i python -p "python38.withPackages (ps: [ ps.django ])"

import django
print(django.__version__)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This opens the door to replace &lt;code&gt;pyenv&lt;/code&gt; and any &lt;code&gt;virtualenv&lt;/code&gt; you will ever need.&lt;/p&gt;
&lt;p&gt;Imagine creating a nix file specific to your project with its dependencies, that you load only when in the project folder. Say goodbye any version manager (&lt;code&gt;pyenv&lt;/code&gt;, &lt;code&gt;nvm&lt;/code&gt;, etc).&lt;/p&gt;
&lt;p&gt;You can read more about building a &lt;code&gt;shell.nix&lt;/code&gt; in the &lt;a href="https://nix.dev/tutorials/declarative-and-reproducible-developer-environments"&gt;nix.dev tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I hope you've learned something with this post, and if you liked it, please let me know in the comments section below or tag me on hachyderm &lt;a href="https://hachyderm.io/@woile"&gt;@woile&lt;/a&gt;.&lt;/p&gt;</description><guid>https://woile.dev/es/posts/nix-journey-part-2-replacing-apt-and-brew/</guid><pubDate>Sun, 08 Jan 2023 14:34:49 GMT</pubDate></item><item><title>Nix journey part 1: creating a flake</title><link>https://woile.dev/es/posts/nix-journey-part-1-creating-a-flake/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;I've started building my own home media center, and I thought it would be a good idea to learn something new and try to make it reproducible, thus I thought of &lt;a href="https://nixos.org/"&gt;nix&lt;/a&gt; for this. Nix is an operating system (which we won't care now), a language (also don't care for now), and a &lt;strong&gt;package manager&lt;/strong&gt;.
We are gonna focus on the package manager part alone, which is already a lot for my brain. This package manager works on mac and linux, and it already has many packages available (bye bye interop problems between mac/linux?)&lt;/p&gt;
&lt;p&gt;The first thing I needed for my raspberry pi was to create a PSK password using &lt;code&gt;wpa_password&lt;/code&gt;, and I tried to run it inside a nix shell on my mac, which didn't work, because &lt;code&gt;wpa_password&lt;/code&gt; doesn't run on a mac.
This was a good opportunity to write something fast, and to make it reusable and reproducible from any unix OS using nix.&lt;/p&gt;
&lt;h3&gt;Objectives&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Create a nix package for &lt;code&gt;wpa_password&lt;/code&gt; (a nix flake)&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;wpa_password&lt;/code&gt; in my home-media project. I want to jump into a shell with the &lt;code&gt;wpa_password&lt;/code&gt; from any unix os, mac or linux (freebsd at some point?)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Creating a nix package&lt;/h3&gt;
&lt;p&gt;I ended up writing the utility in rust, which took me a bunch of hours, the repo &lt;a href="https://github.com/woile/wpa_passphrase_rs"&gt;wpa_passphrase_rs&lt;/a&gt; contains the project finalized.&lt;/p&gt;
&lt;p&gt;After a lot of reading, and wrapping my mind around nix, which I had 0 knowledge before, everything points out that flakes are the new kid in town, and that's what I should use in my project.&lt;/p&gt;
&lt;p&gt;I have a take on nix status, which may need corroboration: nix is moving away from the old way to the new (flakes) way, and there are many outdated posts, and commands. Many commands that fit the pattern &lt;code&gt;nix-*&lt;/code&gt; are no longer used, and instead people now use the new &lt;code&gt;nix &amp;lt;command&amp;gt;&lt;/code&gt; instead. For example, things like &lt;code&gt;nix-shell&lt;/code&gt; are not used much anymore.&lt;/p&gt;
&lt;p&gt;Going back to the nix flake, If you have &lt;a href="https://nixos.org/download.html"&gt;installed nix&lt;/a&gt;, &lt;strong&gt;flakes must be enabled&lt;/strong&gt;, because it's an experimental feature.&lt;/p&gt;
&lt;p&gt;For mac (which only supports multiuser installation):&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;echo 'experimental-features = nix-command flakes' &amp;gt;&amp;gt; /etc/nix/nix.conf
# you may use ~/.config/nix/nix.conf on linux&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;What are flakes?&lt;/h4&gt;
&lt;p&gt;According to &lt;a href="https://nixos.wiki/wiki/Flakes"&gt;nix's wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flakes allow you to specify your code's dependencies (e.g. remote Git repositories) in a &lt;strong&gt;declarative way&lt;/strong&gt;, simply by listing them inside a¬†&lt;code&gt;flake.nix&lt;/code&gt;¬†file.
Each dependency gets pinned, that is: its commit hash gets automatically stored into a file - named¬†&lt;code&gt;flake.lock&lt;/code&gt;¬†- making it easy to, upgrade it
Flakes replace the nix-channels command and things like ad-hoc invocations of¬†&lt;code&gt;builtins.fetchgit&lt;/code&gt;¬†- no more worrying about keeping your channels in sync, no more worrying about forgetting about a dependency deep down in your tree: everything's at hand right inside¬†&lt;code&gt;flake.lock&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Seems like we are gonna need two files: &lt;code&gt;flake.nix&lt;/code&gt; and &lt;code&gt;flake.lock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The next step is to create the flake from a template. What available templates do we have? I wonder...&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix flake show templates&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;github:NixOS/templates/2d6dcce2f3898090c8eda16a16abdff8a80e8ebf
‚îú‚îÄ‚îÄ‚îÄdefaultTemplate: template: A very basic flake
‚îî‚îÄ‚îÄ‚îÄtemplates
    ‚îú‚îÄ‚îÄ‚îÄbash-hello: template: An over-engineered Hello World in bash
    ‚îú‚îÄ‚îÄ‚îÄc-hello: template: An over-engineered Hello World in C
    ‚îú‚îÄ‚îÄ‚îÄcompat: template: A default.nix and shell.nix for backward compatibility with Nix installations that don't support flakes
    ‚îú‚îÄ‚îÄ‚îÄfull: template: A template that shows all standard flake outputs
    ‚îú‚îÄ‚îÄ‚îÄgo-hello: template: A simple Go package
    ‚îú‚îÄ‚îÄ‚îÄhaskell-hello: template: A Hello World in Haskell with one dependency
    ‚îú‚îÄ‚îÄ‚îÄhaskell-nix: template: An haskell.nix template using hix
    ‚îú‚îÄ‚îÄ‚îÄhercules-ci: template: An example for Hercules-CI, containing only the necessary attributes for adding to your project.
    ‚îú‚îÄ‚îÄ‚îÄpandoc-xelatex: template: A report built with Pandoc, XeLaTex and a custom font
    ‚îú‚îÄ‚îÄ‚îÄpython: template: Python template, using poetry2nix
    ‚îú‚îÄ‚îÄ‚îÄrust: template: Rust template, using Naersk
    ‚îú‚îÄ‚îÄ‚îÄrust-web-server: template: A Rust web server including a NixOS module
    ‚îú‚îÄ‚îÄ‚îÄsimpleContainer: template: A NixOS container running apache-httpd
    ‚îî‚îÄ‚îÄ‚îÄtrivial: template: A very basic flake&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fantastic! Look at that! There's a python version and even a rust web server. The one I need is the rust template, let's use that one as a base.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix flake init -t templates#rust&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that was it, it worked. This is going well. I can create a binary inside &lt;code&gt;./result/bin&lt;/code&gt; by running&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix build&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or use it by running&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix run&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;My mind is blown at this point ü§Ø&lt;/p&gt;
&lt;h3&gt;Using the flake somewhere else&lt;/h3&gt;
&lt;p&gt;I couldn't find much about this, as I said, there's a mix of old and new information.
I think it clicked for me, when I realized that the &lt;code&gt;nix&lt;/code&gt; command is new, and it's integration with flakes goes to its core (am I correct on this?).&lt;/p&gt;
&lt;p&gt;Using the flake becomes straightforward.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix shell 'github:woile/wpa_passphrase_rs'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And &lt;code&gt;wpa_password&lt;/code&gt; will appear on my &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;wpa_password --help&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can exit with a &lt;kbd&gt;CTRL&lt;/kbd&gt; + &lt;kbd&gt;D&lt;/kbd&gt;.&lt;/p&gt;
&lt;h3&gt;What's next?&lt;/h3&gt;
&lt;p&gt;What's the right way to make it declarative? I want to have a file with the dependencies required for my home media project, and I'd like to jump into a shell with everything present.&lt;/p&gt;
&lt;p&gt;Is there a different strategy for this?&lt;/p&gt;
&lt;p&gt;How to use &lt;a href="https://github.com/NixOS/nixops"&gt;NixOps&lt;/a&gt; to provision all my raspberries and any other machine that joins the fleet?&lt;/p&gt;
&lt;p&gt;This &lt;a href="https://nixos.wiki/wiki/Ubuntu_vs._NixOS"&gt;comparison between Ubuntu and Nix&lt;/a&gt; appears to be useful, I should read as well.&lt;/p&gt;
&lt;p&gt;Please let me know in the comments section below or tag me on hachyderm &lt;a href="https://hachyderm.io/@woile"&gt;@woile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thanks for reading&lt;/p&gt;</description><guid>https://woile.dev/es/posts/nix-journey-part-1-creating-a-flake/</guid><pubDate>Fri, 30 Dec 2022 16:04:18 GMT</pubDate></item><item><title>A Rust web app with HTML templates</title><link>https://woile.dev/es/posts/web-app-with-template-in-rust/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;The other day, I was helping my girlfriend with Go templates in a web server, and the internet is full of tutorials and explanations. And I thought, what about doing the same in Rust? How hard can it be?&lt;/p&gt;
&lt;p&gt;Spoilers: it's easy, but there's not much information around&lt;/p&gt;
&lt;p&gt;Let's change that!&lt;/p&gt;
&lt;h3&gt;The stack&lt;/h3&gt;
&lt;p&gt;If you come from a language with a big standard library like Go, you should know that rust is a bit more lightweight. The language has decided to provide a slim std library with a top of the line package manager and tools. It's up to the community to provide packages like web servers or templating.&lt;/p&gt;
&lt;p&gt;If you come from Python, even though there's a big standard library, when doing web, is not used by developers. Instead, you are probably used to libraries like Django, Jinja2 or Fastapi. If that's the case, you are gonna feel familiar with the following stack.&lt;/p&gt;
&lt;p&gt;This makes me wonder... will Go end up in the same direction as python? Is there something in the standard library that the community doesn't use, and instead, relies on a third party package? Anyways...&lt;/p&gt;
&lt;p&gt;If you come from Javascript, you are probably used to installing many dependencies, so you are already familiar with what's coming next.&lt;/p&gt;
&lt;p&gt;Let's get back to our stack.&lt;/p&gt;
&lt;h4&gt;Axum&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/tokio-rs/axum"&gt;Axum&lt;/a&gt; is one of the favorite web frameworks in the rust landscape. It's not as mature as Actix Web (which continues to rock). But it's getting a lot of traction, because of it's great integration with tokio and its ecosystem. &lt;a href="https://github.com/tokio-rs/axum"&gt;Axum&lt;/a&gt; was created by &lt;a href="https://github.com/davidpdrsn"&gt;David Pedersen&lt;/a&gt; from &lt;a href="https://github.com/EmbarkStudios"&gt;EmbarkStudios&lt;/a&gt;. This company seems to be taking rust to the next level üôåüèº üöÄ.&lt;/p&gt;
&lt;h4&gt;Minijinja&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/mitsuhiko/minijinja/"&gt;Minijinja&lt;/a&gt; is the rust implementation of Python's Jinja2 by the very same awesome author: &lt;a href="https://lucumr.pocoo.org/"&gt;mitsuhiko&lt;/a&gt;. A lot of people are already familiar with it and with good reason, it's easy to use.&lt;/p&gt;
&lt;h4&gt;Tokio&lt;/h4&gt;
&lt;p&gt;The most popular async runtime. It's ideal for writing network applications. Like our web app, built with Axum.
&lt;a href="https://tokio.rs/"&gt;Tokio&lt;/a&gt; has a big ecosystem, from tracing to database drivers.&lt;/p&gt;
&lt;h4&gt;Serde&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://serde.rs/"&gt;Serde&lt;/a&gt; again, is the most popular way to serialize and deserialize data structures in rust. You serialize or deserialize from one format to another. For example, if you receive a JSON as bytes from an HTTP request, with serde you are going to be able to read the different fields, or load some of that information into a &lt;code&gt;struct&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://serde.rs/"&gt;Serde&lt;/a&gt;'s most common way to use is to derive the &lt;code&gt;Serialize&lt;/code&gt; or &lt;code&gt;Deserialize&lt;/code&gt; macros in your &lt;code&gt;struct&lt;/code&gt;. From there,
you can probably read from, or serialize into different formats, many implemented by the community. Some of the list include JSON, TOML, AVRO, and more.&lt;/p&gt;
&lt;p&gt;In our case, minijinja requires the &lt;code&gt;Serialize&lt;/code&gt; macro in our structs to render the templates.&lt;/p&gt;
&lt;h3&gt;Set up&lt;/h3&gt;
&lt;p&gt;You've already &lt;a href="https://www.rust-lang.org/tools/install"&gt;installed rust&lt;/a&gt;, so go to your projects folder
and create a new rust project.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;cargo new web-template-rs
cd web-template-rs/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the following dependencies.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;cargo add axum \
    tokio -F tokio/full \
    serde -F serde/derive \
    minijinja -F minijinja/builtins&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use the &lt;code&gt;-F&lt;/code&gt; flag to signal which features to include from those crates.&lt;/p&gt;
&lt;h3&gt;The Code&lt;/h3&gt;
&lt;p&gt;We are now ready to start. And we won't need anything else.&lt;/p&gt;
&lt;p&gt;A basic webserver returning HTML without a template looks something like this:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-rust"&gt;use axum::{response::Html, routing::get, Router};

async fn home() -&amp;gt; Html&amp;lt;&amp;amp;'static str&amp;gt; {
    Html("hello world")
}

#[tokio::main]
async fn main() {
    // build our application with a single route
    let app = Router::new()
        .route(
            "/",
            get(home),
        );

    // run it with hyper on localhost:3000
    axum::Server::bind(&amp;amp;"0.0.0.0:3000".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To run our application we run&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;cargo run&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because we haven't configured any logging, you won't see anything in your terminal after running, that's fine.
If you want to learn how to do it, check the &lt;a href="https://github.com/tokio-rs/axum/tree/main/examples/tracing-aka-logging"&gt;tracing-example&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the meanwhile, in your browser go to &lt;code&gt;0.0.0.0:3000&lt;/code&gt; and observe the "hello world" text.&lt;/p&gt;
&lt;h4&gt;What has happened here?&lt;/h4&gt;
&lt;p&gt;When you type a URL or IP in the browser and press &lt;kbd&gt;enter&lt;/kbd&gt;, the browser will "craft"
a GET HTTP request, and send it over a TCP connection to the given IP. If you provide a URL instead (&lt;code&gt;www.example.com&lt;/code&gt;), the browser would have to resolve the IP through DNS. But in our case, we are using directly an IP.&lt;/p&gt;
&lt;p&gt;What are all these acronyms? &lt;a href="https://www.ietf.org/rfc/rfc793.html"&gt;TCP&lt;/a&gt;, &lt;a href="https://www.rfc-editor.org/rfc/rfc791.html"&gt;IP&lt;/a&gt;, &lt;a href="https://www.rfc-editor.org/rfc/rfc2616"&gt;HTTP&lt;/a&gt;, &lt;a href="https://www.rfc-editor.org/rfc/rfc1035.html"&gt;DNS&lt;/a&gt;. They are all Internet Standards. Conventions to guarantee interoperability, they make the internet work. Then is up to people to make actual tools around those protocols. If you want your coffee machine to communicate over the internet, when you start coding its code, you will have to handle all those protocols (or find libraries that already do it for you).&lt;/p&gt;
&lt;p&gt;Remember: &lt;strong&gt;HTTP is plain text&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The request your browser will craft, will look something like this:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-http"&gt;GET / HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0
Accept: */*&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it will be sent over the internet inside an HTTP request, which itself will travel inside a TCP packet, which itself travels inside an IP packet. But actually, we are doing this on our local machine, so it won't reach the internet, your computer knows there is someone listening to &lt;code&gt;0.0.0.0&lt;/code&gt; right away.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;   IP
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ          TCP                   ‚îÇ
 ‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 ‚îÇ         ‚îÇ           HTTP       ‚îÇ
 ‚îÇ         ‚îÇ          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 ‚îÇ         ‚îÇ          ‚îÇ  GET /    ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The request will be received by our rust web server, and it will attempt to handle the "requested" path (&lt;code&gt;GET /&lt;/code&gt;).
No matter what language you use: rust, python, go, js, etc. requests are all plain text.&lt;/p&gt;
&lt;p&gt;Our rust web server, actually knows how to handle that request, because it includes a &lt;code&gt;route&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-rs"&gt;// ...
.route(
    "/",
    get(home),
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://github.com/tokio-rs/axum"&gt;Axum&lt;/a&gt; sees the &lt;code&gt;/&lt;/code&gt; and it know it has a function to handle that path. That function actually means something like&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;return an HTTP response containing HTML with the text "hello world"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And what will axum create? &lt;strong&gt;a plain text HTTP response&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-http"&gt;HTTP/1.1 200 OK
content-type: text/html; charset=utf-8
content-length: 11
date: Mon, 17 Oct 2022 08:03:24 GMT

hello world&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Your browser will receive the response and render a nice white background with the given text.&lt;/p&gt;
&lt;p&gt;Enough with networking lessons woile! I want to know how to use templates.&lt;/p&gt;
&lt;p&gt;True, true... I forgot where were we going with all this... but do we know what templates are?&lt;/p&gt;
&lt;h3&gt;Templates&lt;/h3&gt;
&lt;p&gt;You mix a "custom language", with your target language. This way, you can output the target language from a different one. Let's say we want to create an HTML with a list of users from Rust, Python or Go:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-html"&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;Timmy&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Benji&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Mimi&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What happens when we have a new user? We would have to edit it manually, right? Can we make this behave "dynamically" instead?&lt;/p&gt;
&lt;p&gt;Yes, using templates. Minijinja is a rust implementation of the popular python's &lt;code&gt;jinja2&lt;/code&gt;. A popular "template engine" with its own language. Template engines are endless, and they don't share the same syntax. Python django's template engine, Go templates, JSX (right?), lodash templates, and more. They end up being similar, they have a way to iterate, show data, or use conditions.&lt;/p&gt;
&lt;p&gt;Now with a template engine, we can write something like this:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-html"&gt;&amp;lt;ul&amp;gt;
    {% for user in users %}
    &amp;lt;li&amp;gt;user.name&amp;lt;/li&amp;gt;
    {% endfor %}
&amp;lt;/ul&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This way, our fictional user service, can take this template, fetch the users, and passing through the template, render the list of users.&lt;/p&gt;
&lt;p&gt;Templates can be a monstrosity. Most of the time, the tooling around them is not good, and you don't get an error until you actually try to render them, you may not get syntax highlight. For example, around Kubernetes there's a famous package manager "Helm", which uses templates on top of YAML. YAML is already a &lt;a href="https://noyaml.com/"&gt;controversial language&lt;/a&gt;, and with a template layer on top, it can become incredibly hard to read and maintain. Spite of this, templates are still &lt;strong&gt;convenient&lt;/strong&gt;, and I don't know of a better alternative.&lt;/p&gt;
&lt;h3&gt;Axum with templates&lt;/h3&gt;
&lt;p&gt;Back to our web application! This time, we are gonna create 2 fictional &lt;code&gt;structs&lt;/code&gt;, that we'll use as examples.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-rs"&gt;use serde::Serialize;

#[derive(Debug, Serialize)]
struct Items {
    id: i32,
    name: String,
}

#[derive(Debug, Serialize)]
struct Profile {
    full_name: String,
    items: Vec&amp;lt;Items&amp;gt;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see we are using serde's &lt;code&gt;Serialize&lt;/code&gt;, so minijinja can use them. And &lt;code&gt;Profile.items&lt;/code&gt; is a &lt;code&gt;Vec&lt;/code&gt;, this way we can showcase an iteration example in the template.&lt;/p&gt;
&lt;p&gt;As we've seen templates, we are ready to write our jinja2 like template in rust.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-rust"&gt;const PROFILE_TEMPLATE: &amp;amp;'static str = r#"
&amp;lt;!doctype html&amp;gt;

&amp;lt;html lang="en"&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset="utf-8"&amp;gt;
  &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1"&amp;gt;

  &amp;lt;title&amp;gt;A Basic HTML5 Template&amp;lt;/title&amp;gt;
  &amp;lt;meta name="description" content="A basic HTML5 Template for new projects."&amp;gt;
  &amp;lt;meta name="author" content="Woile"&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Profile of {{ profile.full_name|title }}&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;This is a template example to show some functionality&amp;lt;/p&amp;gt;
    &amp;lt;h2&amp;gt;Items&amp;lt;/h3&amp;gt;
    &amp;lt;ul&amp;gt;
        {% for item in profile.items %}
        &amp;lt;li&amp;gt;{{ item.name }} ({{ item.id }})&amp;lt;/li&amp;gt;
        {% endfor %}
    &amp;lt;ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
"#;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Right in the body of the HTML, we show the &lt;code&gt;profile.full_name&lt;/code&gt;, and then we iterate over each item, displaying the &lt;code&gt;name&lt;/code&gt; and the &lt;code&gt;id&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And for Axum, we add a new route, that will create some example structs.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-rs"&gt;use axum::{response::Html, routing::get, Router, extract::Path};
use minijinja::render;

async fn home() -&amp;gt; Html&amp;lt;&amp;amp;'static str&amp;gt; {
    Html("hello world")
}

async fn get_profile(Path(profile_name): Path&amp;lt;String&amp;gt;) -&amp;gt; Html&amp;lt;String&amp;gt; {
    let orders_example = vec![
        Items {
            id: 1,
            name: "Article banana".into(),
        },
        Items {
            id: 2,
            name: "Article apple".into(),
        },
    ];
    let profile_example = Profile {
        full_name: profile_name,
        items: orders_example,
    };
    let r = render!(PROFILE_TEMPLATE, profile =&amp;gt; profile_example );
    Html(r)
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route(
            "/",
            get(home),
        )
        .route(
            "/:profile_name",
            get(get_profile),
        );
    // run it with hyper on localhost:3000
    axum::Server::bind(&amp;amp;"0.0.0.0:3000".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Too complicated?&lt;/p&gt;
&lt;p&gt;Let's take a look at this 2 lines:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-rust"&gt;"/:profile_name",
get(get_profile),&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line is the &lt;code&gt;path&lt;/code&gt;, which is a the root &lt;code&gt;/&lt;/code&gt; + a variable value &lt;code&gt;:profile_name&lt;/code&gt;.
And right in the next line, we call the &lt;code&gt;get_profile&lt;/code&gt;, which we can see how it uses the &lt;code&gt;profile_name&lt;/code&gt; variable, extracted from the &lt;code&gt;path&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After that, we create the example &lt;code&gt;structs&lt;/code&gt;. In a real example, that information would probably come from a database.&lt;/p&gt;
&lt;p&gt;And then, inside the &lt;code&gt;get_profile&lt;/code&gt; we have:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-rust"&gt;let r = render!(PROFILE_TEMPLATE, profile =&amp;gt; profile_example );
Html(r)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where &lt;code&gt;render!&lt;/code&gt; is minijinja's macro, that receives the template we previous declared, and then we provide some kind of "map" between the variables used in the template first, and then the rust variable.&lt;/p&gt;
&lt;p&gt;A downside here is, that if we have an error in our template, we are only going to see it during runtime.
But on the bright side, this introduction was a quick way to get started with templates and axum in Rust.&lt;/p&gt;
&lt;p&gt;The code is available on &lt;a href="https://github.com/woile/web-template-rs-example"&gt;github.com/woile/web-template-rs-example&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hey, hello üëã&lt;/p&gt;
&lt;p&gt;Interested in what I write? follow me on &lt;a href="https://twitter.com/santiwilly"&gt;twitter&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description><guid>https://woile.dev/es/posts/web-app-with-template-in-rust/</guid><pubDate>Sun, 16 Oct 2022 15:27:25 GMT</pubDate></item></channel></rss>