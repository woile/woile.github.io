<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Willy's blog (Publicaciones sobre kubernetes)</title><link>https://woile.dev/</link><description></description><atom:link href="https://woile.dev/es/categories/kubernetes.xml" rel="self" type="application/rss+xml"></atom:link><language>es</language><copyright>Contents © 2023 &lt;a href="mailto:santiwilly@gmail.com"&gt;Woile&lt;/a&gt; </copyright><lastBuildDate>Sun, 15 Jan 2023 08:57:29 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Helm 3 - Crafting a Chart</title><link>https://woile.dev/es/posts/helm-3-crafting-a-chart/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;This post focuses on &lt;strong&gt;creating and releasing a chart&lt;/strong&gt;, not consuming from a Helm Chart Repository.&lt;/p&gt;
&lt;p&gt;Helm is an &lt;strong&gt;advanced&lt;/strong&gt; tool used by kubernetes people, some "lingo" (jargon) is used here.
Please leave a comment if you want more information.&lt;/p&gt;
&lt;p&gt;Helm allows to &lt;strong&gt;"package"&lt;/strong&gt; kubernetes applications, it simplifies the distribution
and installation. While doing so, it checks dependencies versions and some other validations.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://helm.sh/docs/intro/"&gt;Official Helm 3 Documentation&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Version used&lt;/h3&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;$ helm version --short
v3.2.4+g0ad800e&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Helm Chart&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A Chart is a Helm package. It contains all of the resource definitions necessary to run an application,
tool, or service inside of a Kubernetes cluster. Think of it as the Kubernetes equivalent of a
Homebrew formula, an apt dpkg, or a Yum RPM file &lt;a href="https://helm.sh/docs/intro/using_helm/#three-big-concepts"&gt;[0]&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For OOP people:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chart ~= class&lt;/li&gt;
&lt;li&gt;Release ~= instance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is important to remember, we are going to be building a &lt;strong&gt;package&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Development of a Chart&lt;/h3&gt;
&lt;h4&gt;Creating a new Chart&lt;/h4&gt;
&lt;p&gt;My recommendation is to create a &lt;code&gt;charts/&lt;/code&gt; folder in the root of your project(s).&lt;/p&gt;
&lt;p&gt;This way each of your projects could become a "chart repository", similar to how hub.helm.sh consumes respositories from different sources in a descentralized way.&lt;/p&gt;
&lt;p&gt;You could do the same for your projects. Each git project becomes a descentralized chart repository,
or you can publish to a centralized chart repository like artifactory or your own github repo.&lt;/p&gt;
&lt;p&gt;In any case, calling it &lt;code&gt;charts/&lt;/code&gt; is informative and flexible enough to choose any option.&lt;/p&gt;
&lt;p&gt;Inside &lt;code&gt;charts/&lt;/code&gt;, we are going to use &lt;code&gt;helm&lt;/code&gt; to create the first boilerplate of our app.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm create &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;p&gt;Along the post we'll use &lt;code&gt;auth-service&lt;/code&gt; as our project example name.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;mkdir auth-service
cd auth-service/
mkdir charts
cd charts/&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm create auth-service&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Structure&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;auth-service/
└── charts/
    └── auth-service/
        ├── charts/
        ├── Chart.yaml
        ├── templates/
        │   ├── deployment.yaml
        │   ├── _helpers.tpl
        │   ├── hpa.yaml
        │   ├── ingress.yaml
        │   ├── NOTES.txt
        │   ├── serviceaccount.yaml
        │   ├── service.yaml
        │   └── tests/
        │       └── test-connection.yaml
        └── values.yaml&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Notes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;appVersion&lt;/code&gt; inside &lt;code&gt;Chart.yaml&lt;/code&gt; references the &lt;strong&gt;application version&lt;/strong&gt; &lt;a href="https://stackoverflow.com/a/60054111/2047185"&gt;[1]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;image.tag&lt;/code&gt; inside &lt;code&gt;values.yaml&lt;/code&gt; references the &lt;strong&gt;docker image version/tag&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;image.tag&lt;/code&gt; is skipped, &lt;code&gt;appVersion&lt;/code&gt; is used instead.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;recommendation&lt;/strong&gt;: use a tool to automatically bump the version, like &lt;a href="https://github.com/commitizen-tools/commitizen"&gt;commitizen&lt;/a&gt;,
during the CI execution, and push back to the repo.&lt;/li&gt;
&lt;li&gt;Whether to use &lt;code&gt;image.tag&lt;/code&gt; or &lt;code&gt;appVersion&lt;/code&gt; is still under debate, you can read more in the
&lt;a href="https://github.com/helm/helm/issues/8194"&gt;github issue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;If you use &lt;code&gt;appVersion&lt;/code&gt; you can use &lt;code&gt;helm history &amp;lt;release_name&amp;gt;&lt;/code&gt; to get info on the versions
per revision.&lt;/li&gt;
&lt;li&gt;You can re-use the same chart to deploy multiple django/rails applications, &lt;a href="https://github.com/helm/helm/issues/8194#issuecomment-658715462"&gt;seems like a
common practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Chart customization&lt;/h4&gt;
&lt;p&gt;I recommend to start with the default helm chart and from there, start
adding any extra stuff that you need.&lt;/p&gt;
&lt;h4&gt;Templating&lt;/h4&gt;
&lt;p&gt;If you have used other template systems like &lt;code&gt;jinja&lt;/code&gt;, or Django's template engine,
Helm's system is not that different: you can apply functions using a pipeline &lt;code&gt;|&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-yaml"&gt;food: {{ .Values.favorite.food | upper | quote }}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Avoid adding complex template tags; the purpose of &lt;code&gt;yaml&lt;/code&gt; is to be &lt;strong&gt;readable&lt;/strong&gt;.
By using templates, we make things more complex, and less readable, &lt;strong&gt;touch only when necessary&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;templates/_helpers.tpl&lt;/code&gt; contains custom functions for your templates, like generating the release name based on values.&lt;/p&gt;
&lt;p&gt;To find problems with you charts, run:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm lint &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Values&lt;/h4&gt;
&lt;p&gt;Place the "configuration" that you want to expose to the users of the chart in
the &lt;code&gt;values.yaml&lt;/code&gt;, even if it's you who's gonna end up using it.
There's no need to parametrize everything, and try to use sensible defaults.&lt;/p&gt;
&lt;p&gt;A good rule is to expose only the things you are going to use and make new
parameters only when you have to.&lt;/p&gt;
&lt;p&gt;Let developers specify unconventional aspects of the application.&lt;/p&gt;
&lt;p&gt;You can also define a &lt;code&gt;values.schema.json&lt;/code&gt; which will be used by helm to validate
the parameters given to Helm &lt;a href="https://helm.sh/docs/topics/charts/#schema-files"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Using custom values&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;values.yaml&lt;/code&gt; is used as default and any extra values provided through &lt;code&gt;--set&lt;/code&gt; or &lt;code&gt;--values&lt;/code&gt;
will be merged into the default &lt;code&gt;values.yaml&lt;/code&gt; inside the chart.&lt;/p&gt;
&lt;p&gt;There are 2 approaches to deal with custom values that I know.&lt;/p&gt;
&lt;h5&gt;Centralized values&lt;/h5&gt;
&lt;p&gt;The first one is to have a centralized place with all the configuration. At the
moment, I know &lt;a href="https://github.com/roboll/helmfile"&gt;helmfile&lt;/a&gt; is being used for this.
You'd specify every configuration per environment per chart in a &lt;code&gt;helmfile.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;h5&gt;Per repository&lt;/h5&gt;
&lt;p&gt;This is the most popular approach. Each "project" is responsible to set the values
per enviroment (&lt;code&gt;production&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;If you are going to modify small aspects of your app, using &lt;code&gt;--set&lt;/code&gt; should be enough.&lt;/p&gt;
&lt;p&gt;A common practice, is to place the production and staging files inside the chart folder,
but in my opinion this should be avoided when possible.&lt;/p&gt;
&lt;p&gt;A Helm chart is a package: &lt;strong&gt;Helm is a package manager&lt;/strong&gt;.
Like apt, pip or npm.
When we use tools like Docker, for example, we provide env variables from outside, they are
not packaged inside the image. This gives the container a lot of flexibility and the
same principle applies to Helm. There's an interesting &lt;a href="https://github.com/helm/helm/issues/6715"&gt;discussion in the helm repo&lt;/a&gt;
about this.&lt;/p&gt;
&lt;p&gt;Ideally, your custom values should live outside the chart, and they should be given to the chart.&lt;/p&gt;
&lt;p&gt;Let's see a setup example for the &lt;code&gt;auth-service&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;auth-service/
├── charts/
│   └── auth-service/
├── charts-values/
│   ├── production/
│   │   ├── redis.yaml
│   │   └── auth-service.yaml
│   └── staging/
│       └── auth-service.yaml
└── src/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The installation command would look like&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm install --values charts-values/production/auth-service.yaml auth-service-prod ./auth-service&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'm not 100% happy with the above setup, mainly with the naming.
But it allows having multiple values per chart per environment.
We could easily add values for a redis pulled from the official Helm hub.
I'd like to hear opinions about it. How'd you do it?&lt;/p&gt;
&lt;h3&gt;Release&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A Release is an instance of a chart running in a Kubernetes cluster. One chart can often be installed many times into the same cluster. And each time it is installed, a &lt;strong&gt;new release is created&lt;/strong&gt;.
Consider a MySQL chart. If you want two databases running in your cluster, you can install that chart twice. Each one will have its own release, which will in turn have its own release name &lt;a href="https://helm.sh/docs/intro/using_helm/#three-big-concepts"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;New release&lt;/h4&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm install &amp;lt;release_name&amp;gt; &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Deploy a new release to the cluster.&lt;/p&gt;
&lt;p&gt;We can also run a dry-run to check what's going to happen:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm install &amp;lt;release_name&amp;gt; &amp;lt;package_name&amp;gt; --dry-run&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm install auth-service-prod ./auth-service&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Notes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package_name&lt;/code&gt; can be a folder, a &lt;code&gt;.tgz&lt;/code&gt; or a url.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;release_name&lt;/code&gt;: the name of this particular release. If the name is different another "instance" will be deployed. So for redis instances it may be worth using different &lt;code&gt;release_name&lt;/code&gt;s, but for your JavaScript app it may not.&lt;/li&gt;
&lt;li&gt;The output of &lt;code&gt;templates/NOTES.txt&lt;/code&gt; is shown in the prompt when making a new release, useful for CI logs.&lt;/li&gt;
&lt;li&gt;If you don't want to provide a &lt;code&gt;&amp;lt;release_name&amp;gt;&lt;/code&gt;, use &lt;code&gt;--generate-name&lt;/code&gt; and it will assign a random &lt;code&gt;&amp;lt;release_name&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Helm stores release config per namespace, so if you want to release 2 redis instances in the same namespace, they should have different &lt;code&gt;&amp;lt;release_name&amp;gt;&lt;/code&gt;s &lt;a href="https://github.com/helm/community/blob/master/helm-v3/003-state.md#namespacing-changes"&gt;[4]&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Helm does not wait until all of the resources are running before it exits &lt;a href="https://helm.sh/docs/intro/using_helm/#helm-install-installing-a-package"&gt;[5]&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;personal&lt;/strong&gt;: use different &lt;code&gt;release_name&lt;/code&gt;s per environment (&lt;code&gt;production&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt;). Even though it may not be necessary, giving that extra information in the name is useful and cheap.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;helm get values &amp;lt;release_name&amp;gt;&lt;/code&gt; to get the values used for the release, useful to check if our custom values were applied properly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Check release status&lt;/h4&gt;
&lt;p&gt;After it is installed, we want to know if everything went well.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm status &amp;lt;release_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm status auth-service-prod&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;An upgrade takes an existing release and upgrades it according to the information you provide. Because Kubernetes charts can be large and complex, Helm tries to perform the &lt;strong&gt;least invasive upgrade&lt;/strong&gt;. It will only update things that have changed &lt;strong&gt;since the last release&lt;/strong&gt;. &lt;a href="https://helm.sh/docs/intro/using_helm/#helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure"&gt;[6]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Uprgrade release&lt;/h4&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm upgrade -f &amp;lt;custom_values.yaml&amp;gt; &amp;lt;release_name&amp;gt; &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm upgrade -f charts-values/production/auth-service.yaml auth-service-prod ./auth-service&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Rollback release&lt;/h4&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm rollback &amp;lt;release_name&amp;gt; &amp;lt;revision&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm rollback auth-service-prod 1&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Notes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Any release version increment will produce a &lt;code&gt;revision&lt;/code&gt; number. It goes from 1..N.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;helm history &amp;lt;release_name&amp;gt;&lt;/code&gt; to see the revisions of your &lt;code&gt;release_name&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Uninstall release&lt;/h4&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm uninstall &amp;lt;release_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I won't go deep into this, but just know it exists, and you can remove an existing release.&lt;/p&gt;
&lt;h4&gt;Automating release cycle&lt;/h4&gt;
&lt;p&gt;A recommended best practice to avoid running &lt;code&gt;helm install&lt;/code&gt; and &lt;code&gt;helm upgrade&lt;/code&gt; &lt;a href="https://helm.sh/docs/howto/charts_tips_and_tricks/#install-or-upgrade-a-release-with-one-command"&gt;[7]&lt;/a&gt; is to use:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm upgrade --install &amp;lt;release_name&amp;gt; --values &amp;lt;custom_values.yaml&amp;gt; &amp;lt;package_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be a benefit in an automated CI/CD pipeline. We let Helm perform the check to know if it's a first time,
or a release upgrade.&lt;/p&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;helm upgrade --install auth-service-prod --values charts-values/production/auth-service.yaml ./auth-service&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Notes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;--atomic&lt;/code&gt; to get automatic rollback on failures.&lt;a href="https://lzone.de/blog/Helm-Best-Practices"&gt;[8]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Complex Charts with Many Dependencies&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;The current best practice for composing a complex application from discrete parts is to create a top-level umbrella chart that exposes the global configurations, and then use the charts/ subdirectory to embed each of the components.&lt;a href="https://helm.sh/docs/howto/charts_tips_and_tricks/#complex-charts-with-many-dependencies"&gt;5&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I think this is an improving point; I haven't understood it by reading the documentation yet.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hey, hello 👋&lt;/p&gt;
&lt;p&gt;If you are interested in what I write, follow me on &lt;a href="https://twitter.com/santiwilly"&gt;twitter&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description><guid>https://woile.dev/es/posts/helm-3-crafting-a-chart/</guid><pubDate>Wed, 15 Jul 2020 13:20:41 GMT</pubDate></item><item><title>Multiple configurations in kubernetes</title><link>https://woile.dev/es/posts/multiple-configurations-in-kubernetes/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;It may happen to you, that you start working with 2 or more different clusters in
kubernetes. At this point, you'll want to have multiple config files, instead of
replacing &lt;code&gt;~/.kube/config&lt;/code&gt;, which is fine the first few times.&lt;/p&gt;
&lt;p&gt;In order to do this we only need to set &lt;code&gt;KUBECONFIG&lt;/code&gt; env variable with the path to the kubeconfigs.&lt;/p&gt;
&lt;p&gt;Create a &lt;code&gt;configs&lt;/code&gt; folder, where the kubernetes config files will live.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;mkdir -p ~/.kube/configs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next thing is to add the env variable to our &lt;code&gt;.bashrc&lt;/code&gt;, &lt;code&gt;.zshrc&lt;/code&gt; or &lt;code&gt;.profile&lt;/code&gt; file,
with the location of our configurations. The paths should be separated by a &lt;code&gt;:&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;export KUBECONFIG=$HOME/.kube/configs/gke-config:$HOME/.kube/configs/eks-config&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reloading our terminal with &lt;code&gt;. ~/.bashrc&lt;/code&gt;, or opening a new one should pick up the changes.&lt;/p&gt;
&lt;h4&gt;Automating the config detection&lt;/h4&gt;
&lt;p&gt;Why not automate this? So everytime we add a new kubeconfig, it's detected automatically.&lt;/p&gt;
&lt;p&gt;Here's my attempt, place this snippet in your &lt;code&gt;.bashrc&lt;/code&gt; or any other terminal file.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;set_kubeconfig() {
    for entry in "$HOME/.kube/configs"/*
    do
        # Get files which do not include "skip"
        if [ -f "$entry" ] &amp;amp;&amp;amp; [[ $entry != *"skip"* ]];then
            kubeconfigs="$kubeconfigs:$entry"
        fi
    done

    # Clean first colons
    kubeconfigs=${kubeconfigs#":"}
    export KUBECONFIG=$kubeconfigs
}

# Execute the function
set_kubeconfig&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This script will get all the &lt;strong&gt;files&lt;/strong&gt; inside &lt;code&gt;~/.kube/configs&lt;/code&gt;,
which do not include &lt;code&gt;skip&lt;/code&gt; in their name, and will set the &lt;code&gt;KUBECONFIG&lt;/code&gt;
variable to the found files.&lt;/p&gt;
&lt;h4&gt;Switching context and namespace&lt;/h4&gt;
&lt;p&gt;Now that our configs are detected automatically, we still have to change manually between
contexts and namespaces. I'll leave here the shortcuts&lt;/p&gt;
&lt;p&gt;Remember that a context is a mix of [cluster, namespace, user].&lt;/p&gt;
&lt;h5&gt;Current configuration&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;kubectl config view --minify  # without minify we'll see all the configs&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;List contexts&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;kubectl config get-contexts&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Swtich context&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;kubectl config use-context &amp;lt;context_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Switch namespace&lt;/h5&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-bash"&gt;kubectl config set-context --current --namespace=&amp;lt;new_namespace&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Find me on twitter: &lt;a href="https://twitter.com/santiwilly"&gt;@santiwilly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thanks for reading!&lt;/p&gt;</description><guid>https://woile.dev/es/posts/multiple-configurations-in-kubernetes/</guid><pubDate>Fri, 08 Nov 2019 18:15:28 GMT</pubDate></item><item><title>Raspberry Pi hobby cluster</title><link>https://woile.dev/es/posts/raspberries-hobby-cluster/</link><dc:creator>Woile</dc:creator><description>&lt;div&gt;&lt;p&gt;In this tutorial we are gonna try to setup a cluster in our home
server built with raspberries.&lt;/p&gt;
&lt;p&gt;In another post I'll describe how to configure a Kubernetes cluster in our raspberries.&lt;/p&gt;
&lt;p&gt;Kubernetes is a container orchestration tool, it can do all of this:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Automatic bin packing&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Self-healing&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Horizontal scaling&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Service discovery and Load balancing&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Automated rollouts and rollbacks&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Secrets and configuration management&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Storage orchestration&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Long running jobs&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Batch execution&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://woile.dev/es/posts/raspberries-hobby-cluster/"&gt;Leer más…&lt;/a&gt; (quedan 3 minutos de lectura)&lt;/p&gt;&lt;/div&gt;</description><guid>https://woile.dev/es/posts/raspberries-hobby-cluster/</guid><pubDate>Fri, 22 Feb 2019 07:46:17 GMT</pubDate></item></channel></rss>