<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Willy's blog (Publicaciones sobre devops)</title><link>https://woile.dev/</link><description></description><atom:link href="https://woile.dev/es/categories/cat_devops.xml" rel="self" type="application/rss+xml"></atom:link><language>es</language><copyright>Contents ¬© 2022 &lt;a href="mailto:santiwilly@gmail.com"&gt;Woile&lt;/a&gt; </copyright><lastBuildDate>Mon, 14 Mar 2022 09:29:32 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Automating semver releases with commitizen</title><link>https://woile.dev/es/posts/automating-semver-releases-with-commitizen/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;&lt;a href="https://semver.org/"&gt;SemVer&lt;/a&gt; is a great way to version an application.
Languages like rust have &lt;a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-cratesio"&gt;fully embraced it&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A SemVer version looks like this: &lt;code&gt;1.2.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Quite simple, right?&lt;/p&gt;
&lt;p&gt;We can map that to &lt;code&gt;MAJOR.MINOR.PATCH&lt;/code&gt; where&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MAJOR&lt;/code&gt; ‚û°Ô∏è BREAKING CHANGES ‚ö†Ô∏è&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MINOR&lt;/code&gt; ‚û°Ô∏è New stuff üéâ&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PATCH&lt;/code&gt; ‚û°Ô∏è Security üîí and bug fixes üêõ&lt;/p&gt;
&lt;p&gt;That's the highlight.&lt;/p&gt;
&lt;h3&gt;Making a new release&lt;/h3&gt;
&lt;p&gt;Usually, when making a new semantic version (semver), you have to review your
commits, check if there's any braking changes, then check if there are new features,
otherwise, it's just a patch. This process can be tedious, but semver gives
developers a lot of information about a release, like if they can update safely,
new features, or they &lt;strong&gt;must&lt;/strong&gt; update.&lt;/p&gt;
&lt;p&gt;The release process can be fully automated, but it has a price.&lt;/p&gt;
&lt;h3&gt;The Price&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Write parseable commits&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Automating release&lt;/h3&gt;
&lt;p&gt;By writing commits this way, we have to think, in that moment, what kind of change
we are introducing. And that information get's encoded in the message.&lt;/p&gt;
&lt;p&gt;Let's see a simple rule for parseable, easy to map messages:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Include MAJOR:, MINOR:, PATCH: at the beginning of each commit. If not present
the commit will be skipped, and it won't be released.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Commits examples:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MAJOR: Change public interface for class User&lt;/p&gt;
&lt;p&gt;MINOR: Add new type of user (employee)&lt;/p&gt;
&lt;p&gt;PATCH: Fix full name not being displayed properly&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that's it! The next step is to use a tool to collect the commits, and generate
the correct &lt;a href="https://semver.org/"&gt;semver&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Commit tips&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Talk imperative and follow this rule: &lt;code&gt;If applied, this commit will &amp;lt;commit message&amp;gt;&lt;/code&gt; &lt;a href="https://chris.beams.io/posts/git-commit/"&gt;0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Keep the subject short&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Introducing commitizen&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/commitizen-tools/commitizen"&gt;Commitizen&lt;/a&gt; is a tool to do exactly that.&lt;/p&gt;
&lt;p&gt;I created it in order to automate that process. Based on existing tools from
the JS ecosystem but which I found hard to use.&lt;/p&gt;
&lt;p&gt;By default it parses the widely popular commit rules: &lt;a href="https://www.conventionalcommits.org/en/v1.0.0/"&gt;conventional commits&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But you can &lt;a href="https://commitizen-tools.github.io/commitizen/customization/#2-customize-through-customizing-a-class"&gt;easily extend commitizen&lt;/a&gt; to create the example given before.&lt;/p&gt;
&lt;p&gt;Not only it will create the version, but it can also generate the changelog.&lt;/p&gt;
&lt;p&gt;It's really easy to use, first create a &lt;code&gt;.cz.toml&lt;/code&gt; file in your project's root.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;[tool.commitizen]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"2.5.1"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;version_files&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"setup.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"Dockerfile"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"src/__version__.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"scripts/publish"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;And that's it, by running a single command we get the version and the changelog.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;cz bump --changelog
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;veresion_files&lt;/code&gt; will also bump the version in the specified files.&lt;/p&gt;
&lt;h3&gt;CI/CD&lt;/h3&gt;
&lt;p&gt;&lt;img alt="diagram of semantic release" src="https://woile.dev/images/automating-deployment-with-commitizen/semantic_release.png"&gt;&lt;/p&gt;
&lt;p&gt;In this diagram, you'd execute commitizen during the "merge job" (green in the diagram), where "bump version" is highlighted.&lt;/p&gt;
&lt;p&gt;For example, if you are using Github Actions, you'd add this to your job:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nt"&gt;on&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;push&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;branches&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;main&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Commitizen then, will generate a new commit, with the updated version in the files and the changelog; and a new tag.&lt;/p&gt;
&lt;p&gt;Both are pushed back.&lt;/p&gt;
&lt;p&gt;For the new commit, we should not trigger again the CI.&lt;/p&gt;
&lt;p&gt;The new tag, instead, should trigger another job, "tag job" (purple in the diagram), which will take care of the release, which can include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;deploying to kubernetes&lt;/li&gt;
&lt;li&gt;publishing to pypi/npm/cargo&lt;/li&gt;
&lt;li&gt;deploying to a cloud service, like AWS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Done!&lt;/p&gt;
&lt;h3&gt;Recap&lt;/h3&gt;
&lt;h4&gt;Standards&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://semver.org/"&gt;semver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.conventionalcommits.org/en/v1.0.0/"&gt;conventional commits&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The Price&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Write parseable commits&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Command&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;cz bump --changelog
&lt;/pre&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Try commitizen and check the &lt;a href="https://github.com/commitizen-tools/commitizen"&gt;repo&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We aim for simplicity, trying to make this process as simple as possible, but
the tool is quite flexible, explore it, and see if it fits for your use cases.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hey, hello üëã&lt;/p&gt;
&lt;p&gt;If you are interested in what I write, follow me on &lt;a href="https://twitter.com/santiwilly"&gt;twitter&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description><guid>https://woile.dev/es/posts/automating-semver-releases-with-commitizen/</guid><pubDate>Wed, 15 Jul 2020 15:27:20 GMT</pubDate></item><item><title>Helm 3 - Crafting a Chart</title><link>https://woile.dev/es/posts/helm-3-crafting-a-chart/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;This post focuses on &lt;strong&gt;creating and releasing a chart&lt;/strong&gt;, not consuming from a Helm Chart Repository.&lt;/p&gt;
&lt;p&gt;Helm is an &lt;strong&gt;advanced&lt;/strong&gt; tool used by kubernetes people, some "lingo" (jargon) is used here.
Please leave a comment if you want more information.&lt;/p&gt;
&lt;p&gt;Helm allows to &lt;strong&gt;"package"&lt;/strong&gt; kubernetes applications, it simplifies the distribution
and installation. While doing so, it checks dependencies versions and some other validations.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://helm.sh/docs/intro/"&gt;Official Helm 3 Documentation&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Version used&lt;/h3&gt;
&lt;pre class="code literal-block"&gt;$ helm version --short
v3.2.4+g0ad800e
&lt;/pre&gt;
&lt;h3&gt;Helm Chart&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A Chart is a Helm package. It contains all of the resource definitions necessary to run an application,
tool, or service inside of a Kubernetes cluster. Think of it as the Kubernetes equivalent of a
Homebrew formula, an apt dpkg, or a Yum RPM file &lt;a href="https://helm.sh/docs/intro/using_helm/#three-big-concepts"&gt;[0]&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For OOP people:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chart ~= class&lt;/li&gt;
&lt;li&gt;Release ~= instance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is important to remember, we are going to be building a &lt;strong&gt;package&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Development of a Chart&lt;/h3&gt;
&lt;h4&gt;Creating a new Chart&lt;/h4&gt;
&lt;p&gt;My recommendation is to create a &lt;code&gt;charts/&lt;/code&gt; folder in the root of your project(s).&lt;/p&gt;
&lt;p&gt;This way each of your projects could become a "chart repository", similar to how hub.helm.sh consumes respositories from different sources in a descentralized way.&lt;/p&gt;
&lt;p&gt;You could do the same for your projects. Each git project becomes a descentralized chart repository,
or you can publish to a centralized chart repository like artifactory or your own github repo.&lt;/p&gt;
&lt;p&gt;In any case, calling it &lt;code&gt;charts/&lt;/code&gt; is informative and flexible enough to choose any option.&lt;/p&gt;
&lt;p&gt;Inside &lt;code&gt;charts/&lt;/code&gt;, we are going to use &lt;code&gt;helm&lt;/code&gt; to create the first boilerplate of our app.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;helm create &amp;lt;package_name&amp;gt;
&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;p&gt;Along the post we'll use &lt;code&gt;auth-service&lt;/code&gt; as our project example name.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;mkdir auth-service
&lt;span class="nb"&gt;cd&lt;/span&gt; auth-service/
mkdir charts
&lt;span class="nb"&gt;cd&lt;/span&gt; charts/
&lt;/pre&gt;
&lt;pre class="code literal-block"&gt;helm create auth-service
&lt;/pre&gt;
&lt;h5&gt;Structure&lt;/h5&gt;
&lt;pre class="code literal-block"&gt;auth-service/
‚îî‚îÄ‚îÄ charts/
    ‚îî‚îÄ‚îÄ auth-service/
        ‚îú‚îÄ‚îÄ charts/
        ‚îú‚îÄ‚îÄ Chart.yaml
        ‚îú‚îÄ‚îÄ templates/
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ deployment.yaml
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _helpers.tpl
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hpa.yaml
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ingress.yaml
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NOTES.txt
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ serviceaccount.yaml
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ service.yaml
        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tests/
        ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ test-connection.yaml
        ‚îî‚îÄ‚îÄ values.yaml
&lt;/pre&gt;
&lt;h5&gt;Notes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;appVersion&lt;/code&gt; inside &lt;code&gt;Chart.yaml&lt;/code&gt; references the &lt;strong&gt;application version&lt;/strong&gt; &lt;a href="https://stackoverflow.com/a/60054111/2047185"&gt;[1]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;image.tag&lt;/code&gt; inside &lt;code&gt;values.yaml&lt;/code&gt; references the &lt;strong&gt;docker image version/tag&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;image.tag&lt;/code&gt; is skipped, &lt;code&gt;appVersion&lt;/code&gt; is used instead.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;recommendation&lt;/strong&gt;: use a tool to automatically bump the version, like &lt;a href="https://github.com/commitizen-tools/commitizen"&gt;commitizen&lt;/a&gt;,
during the CI execution, and push back to the repo.&lt;/li&gt;
&lt;li&gt;Whether to use &lt;code&gt;image.tag&lt;/code&gt; or &lt;code&gt;appVersion&lt;/code&gt; is still under debate, you can read more in the
&lt;a href="https://github.com/helm/helm/issues/8194"&gt;github issue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;If you use &lt;code&gt;appVersion&lt;/code&gt; you can use &lt;code&gt;helm history &amp;lt;release_name&amp;gt;&lt;/code&gt; to get info on the versions
per revision.&lt;/li&gt;
&lt;li&gt;You can re-use the same chart to deploy multiple django/rails applications, &lt;a href="https://github.com/helm/helm/issues/8194#issuecomment-658715462"&gt;seems like a
common practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Chart customization&lt;/h4&gt;
&lt;p&gt;I recommend to start with the default helm chart and from there, start
adding any extra stuff that you need.&lt;/p&gt;
&lt;h4&gt;Templating&lt;/h4&gt;
&lt;p&gt;If you have used other template systems like &lt;code&gt;jinja&lt;/code&gt;, or Django's template engine,
Helm's system is not that different: you can apply functions using a pipeline &lt;code&gt;|&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nt"&gt;food&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;{{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;.Values.favorite.food | upper | quote&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;}}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Avoid adding complex template tags; the purpose of &lt;code&gt;yaml&lt;/code&gt; is to be &lt;strong&gt;readable&lt;/strong&gt;.
By using templates, we make things more complex, and less readable, &lt;strong&gt;touch only when necessary&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;templates/_helpers.tpl&lt;/code&gt; contains custom functions for your templates, like generating the release name based on values.&lt;/p&gt;
&lt;p&gt;To find problems with you charts, run:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;helm lint &amp;lt;package_name&amp;gt;
&lt;/pre&gt;
&lt;h4&gt;Values&lt;/h4&gt;
&lt;p&gt;Place the "configuration" that you want to expose to the users of the chart in
the &lt;code&gt;values.yaml&lt;/code&gt;, even if it's you who's gonna end up using it.
There's no need to parametrize everything, and try to use sensible defaults.&lt;/p&gt;
&lt;p&gt;A good rule is to expose only the things you are going to use and make new
parameters only when you have to.&lt;/p&gt;
&lt;p&gt;Let developers specify unconventional aspects of the application.&lt;/p&gt;
&lt;p&gt;You can also define a &lt;code&gt;values.schema.json&lt;/code&gt; which will be used by helm to validate
the parameters given to Helm &lt;a href="https://helm.sh/docs/topics/charts/#schema-files"&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Using custom values&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;values.yaml&lt;/code&gt; is used as default and any extra values provided through &lt;code&gt;--set&lt;/code&gt; or &lt;code&gt;--values&lt;/code&gt;
will be merged into the default &lt;code&gt;values.yaml&lt;/code&gt; inside the chart.&lt;/p&gt;
&lt;p&gt;There are 2 approaches to deal with custom values that I know.&lt;/p&gt;
&lt;h5&gt;Centralized values&lt;/h5&gt;
&lt;p&gt;The first one is to have a centralized place with all the configuration. At the
moment, I know &lt;a href="https://github.com/roboll/helmfile"&gt;helmfile&lt;/a&gt; is being used for this.
You'd specify every configuration per environment per chart in a &lt;code&gt;helmfile.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;h5&gt;Per repository&lt;/h5&gt;
&lt;p&gt;This is the most popular approach. Each "project" is responsible to set the values
per enviroment (&lt;code&gt;production&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;If you are going to modify small aspects of your app, using &lt;code&gt;--set&lt;/code&gt; should be enough.&lt;/p&gt;
&lt;p&gt;A common practice, is to place the production and staging files inside the chart folder,
but in my opinion this should be avoided when possible.&lt;/p&gt;
&lt;p&gt;A Helm chart is a package: &lt;strong&gt;Helm is a package manager&lt;/strong&gt;.
Like apt, pip or npm.
When we use tools like Docker, for example, we provide env variables from outside, they are
not packaged inside the image. This gives the container a lot of flexibility and the
same principle applies to Helm. There's an interesting &lt;a href="https://github.com/helm/helm/issues/6715"&gt;discussion in the helm repo&lt;/a&gt;
about this.&lt;/p&gt;
&lt;p&gt;Ideally, your custom values should live outside the chart, and they should be given to the chart.&lt;/p&gt;
&lt;p&gt;Let's see a setup example for the &lt;code&gt;auth-service&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;auth-service/
‚îú‚îÄ‚îÄ charts/
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ auth-service/
‚îú‚îÄ‚îÄ charts-values/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ production/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ redis.yaml
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ auth-service.yaml
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ staging/
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ auth-service.yaml
‚îî‚îÄ‚îÄ src/
&lt;/pre&gt;
&lt;p&gt;The installation command would look like&lt;/p&gt;
&lt;pre class="code literal-block"&gt;helm install --values charts-values/production/auth-service.yaml auth-service-prod ./auth-service
&lt;/pre&gt;
&lt;p&gt;I'm not 100% happy with the above setup, mainly with the naming.
But it allows having multiple values per chart per environment.
We could easily add values for a redis pulled from the official Helm hub.
I'd like to hear opinions about it. How'd you do it?&lt;/p&gt;
&lt;h3&gt;Release&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A Release is an instance of a chart running in a Kubernetes cluster. One chart can often be installed many times into the same cluster. And each time it is installed, a &lt;strong&gt;new release is created&lt;/strong&gt;.
Consider a MySQL chart. If you want two databases running in your cluster, you can install that chart twice. Each one will have its own release, which will in turn have its own release name &lt;a href="https://helm.sh/docs/intro/using_helm/#three-big-concepts"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;New release&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;helm install &amp;lt;release_name&amp;gt; &amp;lt;package_name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;Deploy a new release to the cluster.&lt;/p&gt;
&lt;p&gt;We can also run a dry-run to check what's going to happen:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;helm install &amp;lt;release_name&amp;gt; &amp;lt;package_name&amp;gt; --dry-run
&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="code literal-block"&gt;helm install auth-service-prod ./auth-service
&lt;/pre&gt;
&lt;h5&gt;Notes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package_name&lt;/code&gt; can be a folder, a &lt;code&gt;.tgz&lt;/code&gt; or a url.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;release_name&lt;/code&gt;: the name of this particular release. If the name is different another "instance" will be deployed. So for redis instances it may be worth using different &lt;code&gt;release_name&lt;/code&gt;s, but for your JavaScript app it may not.&lt;/li&gt;
&lt;li&gt;The output of &lt;code&gt;templates/NOTES.txt&lt;/code&gt; is shown in the prompt when making a new release, useful for CI logs.&lt;/li&gt;
&lt;li&gt;If you don't want to provide a &lt;code&gt;&amp;lt;release_name&amp;gt;&lt;/code&gt;, use &lt;code&gt;--generate-name&lt;/code&gt; and it will assign a random &lt;code&gt;&amp;lt;release_name&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Helm stores release config per namespace, so if you want to release 2 redis instances in the same namespace, they should have different &lt;code&gt;&amp;lt;release_name&amp;gt;&lt;/code&gt;s &lt;a href="https://github.com/helm/community/blob/master/helm-v3/003-state.md#namespacing-changes"&gt;[4]&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Helm does not wait until all of the resources are running before it exits &lt;a href="https://helm.sh/docs/intro/using_helm/#helm-install-installing-a-package"&gt;[5]&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;personal&lt;/strong&gt;: use different &lt;code&gt;release_name&lt;/code&gt;s per environment (&lt;code&gt;production&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt;). Even though it may not be necessary, giving that extra information in the name is useful and cheap.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;helm get values &amp;lt;release_name&amp;gt;&lt;/code&gt; to get the values used for the release, useful to check if our custom values were applied properly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Check release status&lt;/h4&gt;
&lt;p&gt;After it is installed, we want to know if everything went well.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;helm status &amp;lt;release_name&amp;gt;
&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="code literal-block"&gt;helm status auth-service-prod
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;An upgrade takes an existing release and upgrades it according to the information you provide. Because Kubernetes charts can be large and complex, Helm tries to perform the &lt;strong&gt;least invasive upgrade&lt;/strong&gt;. It will only update things that have changed &lt;strong&gt;since the last release&lt;/strong&gt;. &lt;a href="https://helm.sh/docs/intro/using_helm/#helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure"&gt;[6]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Uprgrade release&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;helm upgrade -f &amp;lt;custom_values.yaml&amp;gt; &amp;lt;release_name&amp;gt; &amp;lt;package_name&amp;gt;
&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="code literal-block"&gt;helm upgrade -f charts-values/production/auth-service.yaml auth-service-prod ./auth-service
&lt;/pre&gt;
&lt;h4&gt;Rollback release&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;helm rollback &amp;lt;release_name&amp;gt; &amp;lt;revision&amp;gt;
&lt;/pre&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="code literal-block"&gt;helm rollback auth-service-prod &lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;
&lt;h5&gt;Notes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Any release version increment will produce a &lt;code&gt;revision&lt;/code&gt; number. It goes from 1..N.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;helm history &amp;lt;release_name&amp;gt;&lt;/code&gt; to see the revisions of your &lt;code&gt;release_name&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Uninstall release&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;helm uninstall &amp;lt;release_name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;I won't go deep into this, but just know it exists, and you can remove an existing release.&lt;/p&gt;
&lt;h4&gt;Automating release cycle&lt;/h4&gt;
&lt;p&gt;A recommended best practice to avoid running &lt;code&gt;helm install&lt;/code&gt; and &lt;code&gt;helm upgrade&lt;/code&gt; &lt;a href="https://helm.sh/docs/howto/charts_tips_and_tricks/#install-or-upgrade-a-release-with-one-command"&gt;[7]&lt;/a&gt; is to use:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;helm upgrade --install &amp;lt;release_name&amp;gt; --values &amp;lt;custom_values.yaml&amp;gt; &amp;lt;package_name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;This can be a benefit in an automated CI/CD pipeline. We let Helm perform the check to know if it's a first time,
or a release upgrade.&lt;/p&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;pre class="code literal-block"&gt;helm upgrade --install auth-service-prod --values charts-values/production/auth-service.yaml ./auth-service
&lt;/pre&gt;
&lt;h5&gt;Notes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;--atomic&lt;/code&gt; to get automatic rollback on failures.&lt;a href="https://lzone.de/blog/Helm-Best-Practices"&gt;[8]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Complex Charts with Many Dependencies&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;The current best practice for composing a complex application from discrete parts is to create a top-level umbrella chart that exposes the global configurations, and then use the charts/ subdirectory to embed each of the components.&lt;a href="https://helm.sh/docs/howto/charts_tips_and_tricks/#complex-charts-with-many-dependencies"&gt;5&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I think this is an improving point; I haven't understood it by reading the documentation yet.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hey, hello üëã&lt;/p&gt;
&lt;p&gt;If you are interested in what I write, follow me on &lt;a href="https://twitter.com/santiwilly"&gt;twitter&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description><guid>https://woile.dev/es/posts/helm-3-crafting-a-chart/</guid><pubDate>Wed, 15 Jul 2020 13:20:41 GMT</pubDate></item></channel></rss>