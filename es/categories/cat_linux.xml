<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Willy's blog (Publicaciones sobre linux)</title><link>https://woile.dev/</link><description></description><atom:link href="https://woile.dev/es/categories/cat_linux.xml" rel="self" type="application/rss+xml"></atom:link><language>es</language><copyright>Contents ¬© 2022 &lt;a href="mailto:santiwilly@gmail.com"&gt;Woile&lt;/a&gt; </copyright><lastBuildDate>Fri, 30 Dec 2022 16:28:46 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Nix journey part 1: creating a flake</title><link>https://woile.dev/es/posts/nix-journey-part-1-creating-a-flake/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;I've started building my own home media center, and I thought it would be a good idea to learn something new and try to make it reproducible, thus I thought of &lt;a href="https://nixos.org/"&gt;nix&lt;/a&gt; for this. Nix is an operating system (which we won't care now), a language (also don't care for now), and a &lt;strong&gt;package manager&lt;/strong&gt;.
We are gonna focus on the package manager part alone, which is already a lot for my brain. This package manager works on mac and linux, and it already has many packages available (bye bye interop problems between mac/linux?)&lt;/p&gt;
&lt;p&gt;The first thing I needed for my raspberry pi was to create a PSK password using &lt;code&gt;wpa_password&lt;/code&gt;, and I tried to run it inside a nix shell on my mac, which didn't work, because &lt;code&gt;wpa_password&lt;/code&gt; doesn't run on a mac.
This was a good opportunity to write something fast, and to make it reusable and reproducible from any unix OS using nix.&lt;/p&gt;
&lt;h3&gt;Objectives&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Create a nix package for &lt;code&gt;wpa_password&lt;/code&gt; (a nix flake)&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;wpa_password&lt;/code&gt; in my home-media project. I want to jump into a shell with the &lt;code&gt;wpa_password&lt;/code&gt; from any unix os, mac or linux (freebsd at some point?)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Creating a nix package&lt;/h3&gt;
&lt;p&gt;I ended up writing the utility in rust, which took me a bunch of hours, the repo &lt;a href="https://github.com/woile/wpa_passphrase_rs"&gt;wpa_passphrase_rs&lt;/a&gt; contains the project finalized.&lt;/p&gt;
&lt;p&gt;After a lot of reading, and wrapping my mind around nix, which I had 0 knowledge before, everything points out that flakes are the new kid in town, and that's what I should use in my project.&lt;/p&gt;
&lt;p&gt;I have a take on nix status, which may need corroboration: nix is moving away from the old way to the new (flakes) way, and there are many outdated posts, and commands. Many commands that fit the pattern &lt;code&gt;nix-*&lt;/code&gt; are no longer used, and instead people now use the new &lt;code&gt;nix &amp;lt;command&amp;gt;&lt;/code&gt; instead. For example, things like &lt;code&gt;nix-shell&lt;/code&gt; are not used much anymore.&lt;/p&gt;
&lt;p&gt;Going back to the nix flake, If you have &lt;a href="https://nixos.org/download.html"&gt;installed nix&lt;/a&gt;, &lt;strong&gt;flakes must be enabled&lt;/strong&gt;, because it's an experimental feature.&lt;/p&gt;
&lt;p&gt;For mac (which only supports multiuser installation):&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;'experimental-features = nix-command flakes'&lt;/span&gt; &amp;gt;&amp;gt; /etc/nix/nix.conf
&lt;span class="c1"&gt;# you may use ~/.config/nix/nix.conf on linux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;What are flakes?&lt;/h4&gt;
&lt;p&gt;According to &lt;a href="https://nixos.wiki/wiki/Flakes"&gt;nix's wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flakes allow you to specify your code's dependencies (e.g. remote Git repositories) in a &lt;strong&gt;declarative way&lt;/strong&gt;, simply by listing them inside a¬†&lt;code&gt;flake.nix&lt;/code&gt;¬†file.
Each dependency gets pinned, that is: its commit hash gets automatically stored into a file - named¬†&lt;code&gt;flake.lock&lt;/code&gt;¬†- making it easy to, upgrade it
Flakes replace the nix-channels command and things like ad-hoc invocations of¬†&lt;code&gt;builtins.fetchgit&lt;/code&gt;¬†- no more worrying about keeping your channels in sync, no more worrying about forgetting about a dependency deep down in your tree: everything's at hand right inside¬†&lt;code&gt;flake.lock&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Seems like we are gonna need two files: &lt;code&gt;flake.nix&lt;/code&gt; and &lt;code&gt;flake.lock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The next step is to create the flake from a template. What available templates do we have? I wonder...&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;nix flake show templates
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;github:NixOS/templates/2d6dcce2f3898090c8eda16a16abdff8a80e8ebf
‚îú‚îÄ‚îÄ‚îÄdefaultTemplate: template: A very basic flake
‚îî‚îÄ‚îÄ‚îÄtemplates
    ‚îú‚îÄ‚îÄ‚îÄbash-hello: template: An over-engineered Hello World in bash
    ‚îú‚îÄ‚îÄ‚îÄc-hello: template: An over-engineered Hello World in C
    ‚îú‚îÄ‚îÄ‚îÄcompat: template: A default.nix and shell.nix for backward compatibility with Nix installations that don't support flakes
    ‚îú‚îÄ‚îÄ‚îÄfull: template: A template that shows all standard flake outputs
    ‚îú‚îÄ‚îÄ‚îÄgo-hello: template: A simple Go package
    ‚îú‚îÄ‚îÄ‚îÄhaskell-hello: template: A Hello World in Haskell with one dependency
    ‚îú‚îÄ‚îÄ‚îÄhaskell-nix: template: An haskell.nix template using hix
    ‚îú‚îÄ‚îÄ‚îÄhercules-ci: template: An example for Hercules-CI, containing only the necessary attributes for adding to your project.
    ‚îú‚îÄ‚îÄ‚îÄpandoc-xelatex: template: A report built with Pandoc, XeLaTex and a custom font
    ‚îú‚îÄ‚îÄ‚îÄpython: template: Python template, using poetry2nix
    ‚îú‚îÄ‚îÄ‚îÄrust: template: Rust template, using Naersk
    ‚îú‚îÄ‚îÄ‚îÄrust-web-server: template: A Rust web server including a NixOS module
    ‚îú‚îÄ‚îÄ‚îÄsimpleContainer: template: A NixOS container running apache-httpd
    ‚îî‚îÄ‚îÄ‚îÄtrivial: template: A very basic flake
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fantastic! Look at that! There's a python version and even a rust web server. The one I need is the rust template, let's use that one as a base.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;nix flake init -t templates#rust
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that was it, it worked. This is going well. I can create a binary inside &lt;code&gt;./result/bin&lt;/code&gt; by running&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;nix build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or use it by running&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;nix run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;My mind is blown at this point ü§Ø&lt;/p&gt;
&lt;h3&gt;Using the flake somewhere else&lt;/h3&gt;
&lt;p&gt;I couldn't find much about this, as I said, there's a mix of old and new information.
I think it clicked for me, when I realized that the &lt;code&gt;nix&lt;/code&gt; command is new, and it's integration with flakes goes to its core (am I correct on this?).&lt;/p&gt;
&lt;p&gt;Using the flake becomes straightforward.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;nix shell &lt;span class="s1"&gt;'github:woile/wpa_passphrase_rs'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;wpa_password&lt;/code&gt; will appear on my &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;wpa_password --help
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can exit with a &lt;kbd&gt;CTRL&lt;/kbd&gt; + &lt;kbd&gt;D&lt;/kbd&gt;.&lt;/p&gt;
&lt;h3&gt;What's next?&lt;/h3&gt;
&lt;p&gt;What's the right way to make it declarative? I want to have a file with the dependencies required for my home media project, and I'd like to jump into a shell with everything present.&lt;/p&gt;
&lt;p&gt;Is there a different strategy for this?&lt;/p&gt;
&lt;p&gt;How to use &lt;a href="https://github.com/NixOS/nixops"&gt;NixOps&lt;/a&gt; to provision all my raspberries and any other machine that joins the fleet?&lt;/p&gt;
&lt;p&gt;This &lt;a href="https://nixos.wiki/wiki/Ubuntu_vs._NixOS"&gt;comparison between Ubuntu and Nix&lt;/a&gt; appears to be useful, I should read as well.&lt;/p&gt;
&lt;p&gt;Please let me know in the comments section below or tag me on hachyderm &lt;a href="https://hachyderm.io/@woile"&gt;@woile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thanks for reading&lt;/p&gt;</description><guid>https://woile.dev/es/posts/nix-journey-part-1-creating-a-flake/</guid><pubDate>Fri, 30 Dec 2022 16:04:18 GMT</pubDate></item><item><title>Digesting Make and Makefiles</title><link>https://woile.dev/es/posts/digesting-make-makefile/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;Make and its makefiles, are a fantastic tool to keep track of the commands needed to build or run an application.
I have recently done a big refactor for a project, where we make heavy use of Make, and decided to write this small piece about Make.&lt;/p&gt;
&lt;p&gt;Just create a &lt;code&gt;Makefile&lt;/code&gt; at the root of your project, start adding commands, and done... right? Not really.&lt;/p&gt;
&lt;p&gt;Let's explore a bit more what I mean, and then try to build a mental model that matches reality a bit better,
closing with some magic you can do with Makefiles.&lt;/p&gt;
&lt;p&gt;Set up a practice field by running in the terminal:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;mkdir /tmp/practice
&lt;span class="nb"&gt;cd&lt;/span&gt; /tmp/practice
touch index.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And write a minimal &lt;code&gt;Makefile&lt;/code&gt; with your favourite editor (E.g: &lt;code&gt;vim Makefile&lt;/code&gt;)&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist
    cp index.html dist/index.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then execute in your terminal:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;make build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will create a folder &lt;code&gt;dist&lt;/code&gt;, and copy &lt;code&gt;index.html&lt;/code&gt; into the folder &lt;code&gt;dist&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is good. Particularly for me, it documents the commands used by the project, and helps future me.&lt;/p&gt;
&lt;p&gt;Let's refactor a bit, to show some extra functionality:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp index.html dist/index.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice the &lt;code&gt;build: dist&lt;/code&gt;, it means: call &lt;code&gt;dist&lt;/code&gt; command &lt;em&gt;before&lt;/em&gt; running &lt;code&gt;build&lt;/code&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;make build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The functionality remains the same.&lt;/p&gt;
&lt;h4&gt;Recap&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;We created two commands: &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;dist&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And &lt;code&gt;dist&lt;/code&gt; is executed by the &lt;code&gt;build&lt;/code&gt; before running itself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is ok, but it's not necessary a correct mental model.
In the Makefile world, commands are not commands... but files.&lt;/p&gt;
&lt;h3&gt;New mental model&lt;/h3&gt;
&lt;p&gt;In a nutshell, make builds a &lt;a href="https://en.wikipedia.org/wiki/Dependency_graph"&gt;dependency graph&lt;/a&gt; of files and folders.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt; and &lt;code&gt;dist&lt;/code&gt; are actually &lt;strong&gt;target files&lt;/strong&gt; (or folders).&lt;/li&gt;
&lt;li&gt;doing &lt;code&gt;build: dist&lt;/code&gt; means that &lt;code&gt;build&lt;/code&gt; depends on &lt;code&gt;dist&lt;/code&gt; existing first.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we had a file called &lt;code&gt;build&lt;/code&gt; , doing &lt;code&gt;make build&lt;/code&gt;, wouldn't execute anything.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;touch build
make build
$ make: `build' is up to date.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we want to actually treat &lt;code&gt;build&lt;/code&gt; as a command, we have to add &lt;code&gt;.PHONY&lt;/code&gt;.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;
&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp index.html dist/index.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This way Make no longer sees &lt;code&gt;build&lt;/code&gt; as a file, but instead as a recipe, and it will be
executed everytime.&lt;/p&gt;
&lt;h3&gt;Back to targets&lt;/h3&gt;
&lt;p&gt;Remember what we said about targets and dependency graph? No? Me neither.
Don't worry, I actually didn't say anything.&lt;/p&gt;
&lt;p&gt;If you treat your targets as &lt;strong&gt;files&lt;/strong&gt;, Make can keep track of the files that have
changed, and update only those.&lt;/p&gt;
&lt;p&gt;By knowing this our previous example could be refactored into:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;dist/index.html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp index.html dist/index.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we tell Make to create our target file:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;make dist/index.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we run multiple times, we get:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;make: `dist/index.html' is up to date.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We would expect that by modifying &lt;code&gt;index.html&lt;/code&gt;, and running &lt;code&gt;make dist/index.html&lt;/code&gt;, it would be rebuilt,
but we are getting the same message.&lt;/p&gt;
&lt;h3&gt;Dependencies&lt;/h3&gt;
&lt;p&gt;We need to tell Make that it depends on another file: &lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;dist/index.html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt;
    cp index.html dist/index.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This time, if &lt;code&gt;index.html&lt;/code&gt; is modified, &lt;code&gt;make dist/index.html&lt;/code&gt; will run again.
Thus, when dependecies are updated, &lt;strong&gt;target files&lt;/strong&gt; are recreated.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Makefile targets and dependencies" src="https://woile.dev/images/makefile/make-targets-deps.png"&gt;&lt;/p&gt;
&lt;h3&gt;Patterns&lt;/h3&gt;
&lt;p&gt;Now let's say we have many html files&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;touch about.html privacy.html docs.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we want to do the same for all the files, without creating many commands in Make.
For this case we use a pattern (&lt;code&gt;%&lt;/code&gt;), and some Make variables:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt;: the target file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt;: the input file&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;dist/%.html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; %.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp $&amp;lt; &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;make dist/about.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we would be explicitly telling Make which file to create.&lt;/p&gt;
&lt;p&gt;But what if we want to copy all the files at the same time?&lt;/p&gt;
&lt;p&gt;Our current implementation, doesn't know about the available files.
And we are providing the &lt;code&gt;about&lt;/code&gt; to the &lt;code&gt;make dist/about.html&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We have to find a way to "know" all the possible targets.&lt;/p&gt;
&lt;h3&gt;Variables&lt;/h3&gt;
&lt;p&gt;We are gonna find the source files (&lt;code&gt;*.html&lt;/code&gt; files which are not in the &lt;code&gt;dist&lt;/code&gt; folder), store in a variable,
and then use that information to create the target html files.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;SRC_HTMLS&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;shell find . -name &lt;span class="s1"&gt;'*.html'&lt;/span&gt; -depth &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;TARGET_HTMLS&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;SRC_HTMLS:./%.html&lt;span class="o"&gt;=&lt;/span&gt;dist/%.html&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;
&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;TARGET_HTMLS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;$(&lt;/span&gt;info Done&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;dist/%.html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; %.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp $&amp;lt; &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;make build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What happens is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt; has all the &lt;code&gt;TARGET_HTMLS&lt;/code&gt; files as dependency&lt;/li&gt;
&lt;li&gt;Make also sees &lt;code&gt;dist/%.html&lt;/code&gt; and the pattern will fit the criteria for each &lt;code&gt;TARGET_HTMLS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;dist/%.html&lt;/code&gt; we have as dependency  the &lt;code&gt;%.html&lt;/code&gt;, so Make takes the pattern and checks if a &lt;code&gt;%.html&lt;/code&gt; file exist&lt;/li&gt;
&lt;li&gt;If the conditions are met, it runs the &lt;code&gt;cp&lt;/code&gt; command for each file, unless they are already present and not updated&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can think of&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;TARGET_HTMLS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;/&lt;span class="n"&gt;index&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;/&lt;span class="n"&gt;about&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;/&lt;span class="n"&gt;docs&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;/&lt;span class="n"&gt;privacy&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Variables can be reference using &lt;code&gt;$()&lt;/code&gt; or &lt;code&gt;${}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We also use &lt;code&gt;$(info Done)&lt;/code&gt; to send information messages to the user.
Make also provides &lt;code&gt;$(warning text‚Ä¶)&lt;/code&gt; for warnings, and
&lt;code&gt;$(error text...)&lt;/code&gt; to exit earlier with an error code different than 0.
See &lt;a href="https://www.gnu.org/software/make/manual/html_node/Make-Control-Functions.html"&gt;Make-Control-Functions&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;One more time&lt;/h3&gt;
&lt;p&gt;Let's start over by removing the &lt;code&gt;dist&lt;/code&gt; folder, and see what happens&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rm -rf dist
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;‚ùØ make build
mkdir dist
cp index.html dist/index.html
cp about.html dist/about.html
cp docs.html dist/docs.html
cp privacy.html dist/privacy.html
Done

‚ùØ make build
Done
make: Nothing to be done for `build'.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, files that have not changed, won't be rebuilt by Make.&lt;/p&gt;
&lt;p&gt;Now, try using &lt;code&gt;touch&lt;/code&gt; on the different &lt;code&gt;html&lt;/code&gt; files and running &lt;code&gt;make build&lt;/code&gt; to see what happens.&lt;/p&gt;
&lt;h3&gt;More functionality&lt;/h3&gt;
&lt;p&gt;Make is a powerful tool, and provides much more functionality, so far with the web stack
I haven't had the need for more complexity.&lt;/p&gt;
&lt;p&gt;I usually wrap docker commands, and make use of different variables, but if the need arises,
make has extra functionality, life:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;if/conditions&lt;/li&gt;
&lt;li&gt;change the shell in which the commands are executed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.delete_on_error&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;Make is usually a good way to keep track of a project's commands, as it's available in Unix systems,
and you can be up and running fast.
But by no means is perfect, it can sometimes be hard to read, or use.
It's not available on Windows. And because it was designed for the C,C++ era, it plays well with files,
but it doesn't mean it fits perfectly the web development paradigm, where you don't "transform" files much
and where &lt;code&gt;docker&lt;/code&gt; is used a lot.&lt;/p&gt;
&lt;p&gt;So depending on your situation, there are some popular alternatives:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/casey/just"&gt;just&lt;/a&gt;: modern approach to make written in rust&lt;/li&gt;
&lt;li&gt;&lt;a href="https://earthly.dev/"&gt;earthly.dev&lt;/a&gt;: repeatable builds based on docker&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bazel.build/"&gt;bazel&lt;/a&gt;: build tool from Google&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/github/scripts-to-rule-them-all"&gt;scripts-to-rule-them-all&lt;/a&gt;: just use scripts, like &lt;a href="https://github.com/encode/starlette/tree/master/scripts"&gt;starlette&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Resources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/make/manual/html_node/"&gt;GNU Make Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://makefiletutorial.com/"&gt;Makefiletutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks for reading! üëã&lt;/p&gt;
&lt;p&gt;If you are interested in what I write, follow me on &lt;a href="https://twitter.com/santiwilly"&gt;twitter&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description><guid>https://woile.dev/es/posts/digesting-make-makefile/</guid><pubDate>Thu, 17 Feb 2022 12:21:47 GMT</pubDate></item><item><title>Decrypt filesystem</title><link>https://woile.dev/es/posts/decrypt-filesystem/</link><dc:creator>Woile</dc:creator><description>&lt;div&gt;&lt;h2&gt;Decrypt ubuntu filesystem&lt;/h2&gt;
&lt;p&gt;If you have encrypted your drive with one of the latest ubuntu version, this is how to decrypt using the command line.&lt;/p&gt;
&lt;p&gt;A few weeks ago I had a problem with my ubuntu (as usual) and I had no clue how to decrypt my file, which it's encrypted by my company's policy.&lt;/p&gt;
&lt;p&gt;Optional: run a &lt;strong&gt;live ubuntu&lt;/strong&gt; if your system is not working properly&lt;/p&gt;
&lt;h3&gt;First option&lt;/h3&gt;
&lt;p&gt;Open a terminal and type &lt;code&gt;sudo ecryptfs-unwrap-passphrase&lt;/code&gt;. Most of the time this should do it.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://woile.dev/es/posts/decrypt-filesystem/"&gt;Leer m√°s‚Ä¶&lt;/a&gt; (quedan 1 minutos de lectura)&lt;/p&gt;&lt;/div&gt;</description><guid>https://woile.dev/es/posts/decrypt-filesystem/</guid><pubDate>Fri, 13 Jul 2018 21:14:43 GMT</pubDate></item><item><title>Get Skype working on Debian Stretch x64 with GNOME3</title><link>https://woile.dev/es/posts/get-skype-working-on-debian-stretch-x64-with-gnome3/</link><dc:creator>Woile</dc:creator><description>&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;Note&lt;/p&gt;
&lt;p&gt;This info is no longer relevant. Right now Skype has been rewritten using &lt;a class="reference external" href="https://electron.atom.io/"&gt;electron&lt;/a&gt; and installing it in a debian based system is no longer a problem.
Right now it doesn't support screensharing and some other features a normal person would expect.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some alternatives I recommend:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://appear.in/"&gt;appear.in&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://tox.chat/"&gt;tox&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://hangouts.google.com/"&gt;hangouts&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://discordapp.com/"&gt;discord&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you really need to install this software, and you cannot use the alternatives, then this guide is for you.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://woile.dev/es/posts/get-skype-working-on-debian-stretch-x64-with-gnome3/"&gt;Leer m√°s‚Ä¶&lt;/a&gt; (quedan 1 minutos de lectura)&lt;/p&gt;&lt;/div&gt;</description><guid>https://woile.dev/es/posts/get-skype-working-on-debian-stretch-x64-with-gnome3/</guid><pubDate>Mon, 19 Sep 2016 10:56:03 GMT</pubDate></item></channel></rss>