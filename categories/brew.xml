<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Willy's blog (Posts about brew)</title><link>https://woile.dev/</link><description></description><atom:link href="https://woile.dev/categories/brew.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents ¬© 2023 &lt;a href="mailto:santiwilly@gmail.com"&gt;Woile&lt;/a&gt; </copyright><lastBuildDate>Sat, 14 Jan 2023 13:54:33 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Nix journey part 2: replacing apt and brew</title><link>https://woile.dev/posts/nix-journey-part-2-replacing-apt-and-brew/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;Even if I still cannot do much with &lt;a href="https://nixos.org/"&gt;nix&lt;/a&gt;, it still provide more advantages over other package managers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multi-platform (mac, linux, etc.)&lt;/li&gt;
&lt;li&gt;Supports side-by-side installation of multiple versions of a package&lt;/li&gt;
&lt;li&gt;Makes it trivial to share development and build environments&lt;/li&gt;
&lt;li&gt;Nix ensures that installing or upgrading one package cannot break other packages&lt;/li&gt;
&lt;li&gt;It has the biggest database of packages (over 80.000 packages)&lt;/li&gt;
&lt;li&gt;I can run other people's commands, for example if I clone a repo and it says "run this nix command to have a development environment", then it doesn't matter if I don't know, I have already started using it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A common situation I often have between linux and mac is running &lt;code&gt;grip&lt;/code&gt; or &lt;code&gt;sed&lt;/code&gt;.
On linux, they are called GNU &lt;code&gt;grep&lt;/code&gt; or GNU &lt;code&gt;sed&lt;/code&gt;, and they are not the same as in mac (freebsd versin), they may not accept the same parameters.
We are gonna see how can to avoid this using nix. And even without using complicated features, it can make your CI system more reproducible.&lt;/p&gt;
&lt;p&gt;Remember &lt;code&gt;nix&lt;/code&gt; is 3 things at the same time: an OS, a package manager and a language.&lt;/p&gt;
&lt;p&gt;This post is about the &lt;strong&gt;package manager&lt;/strong&gt;. I don't have much interest in the language, but more and more I think I'll have to learn it.&lt;/p&gt;
&lt;p&gt;Let's start by acknowledging a source of confusion:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There is an old interface with counterintuitive commands&lt;/strong&gt; (&lt;code&gt;nix-env -iA ...&lt;/code&gt;, &lt;code&gt;nix-shell -p ...&lt;/code&gt;), which I found hard to remember, and I don't get why they "commands" start with a dash (&lt;code&gt;-&lt;/code&gt;). I'm used to cli's doing &lt;code&gt;cli &amp;lt;command&amp;gt; [--options]&lt;/code&gt;. Nowadays there's a new cli called just &lt;code&gt;nix&lt;/code&gt;, let's see if we can do everything with it.&lt;/p&gt;
&lt;p&gt;And make sure you have &lt;a href="https://nixos.org/download.html"&gt;installed Nix: the package manager&lt;/a&gt; in your system. The installation is straightforward. I was personally blocked, because at some point in my dotfiles I was hardcoding the &lt;code&gt;PATH&lt;/code&gt;, making nix never appear ü§¶‚Äç‚ôÇÔ∏è.&lt;/p&gt;
&lt;p&gt;And &lt;a href="https://nixos.wiki/wiki/Flakes#Enable_flakes"&gt;enable flakes&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Installing packages&lt;/h3&gt;
&lt;p&gt;Install a package like on &lt;code&gt;brew&lt;/code&gt; or &lt;code&gt;apt&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile install nixpkgs#htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See also the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile-install.html"&gt;profile install command reference&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the old version of nix, we would run:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix-env -iA nixpkgs.htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nix forces us to specify a "repository" (or "namespace") when installing a package (&lt;code&gt;nixpkgs&lt;/code&gt;), which could be different, like github. And I think this is a good thing. From my understanding, nix doesn't care where the package is, because each package has a lock file, tracking all the dependencies. Okay, it could be a problem if one of the "repositories" is down, but using &lt;code&gt;nixpkgs&lt;/code&gt; mainly and github for niche packages should be fine.&lt;/p&gt;
&lt;h4&gt;What are profiles?&lt;/h4&gt;
&lt;p&gt;Disclaimer: I may be wrong on this, I'm starting to understand it.&lt;/p&gt;
&lt;p&gt;The way to see &lt;code&gt;profiles&lt;/code&gt; is like "your user's packages". &lt;code&gt;nix profile&lt;/code&gt; links packages to your &lt;code&gt;~/.nix-profile/&lt;/code&gt;. You can specify other's profiles by using the flag &lt;code&gt;-p&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can find more in the &lt;a href="https://nixos.org/manual/nix/stable/package-management/profiles.html"&gt;package-management section of the manual&lt;/a&gt; and &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile.html"&gt;the profile command reference&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Searching packages&lt;/h3&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix search nixpkgs#htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-search.html"&gt;search command reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We see again &lt;code&gt;nixpkgs&lt;/code&gt;, because we have to let nix know from where, and then what we are looking for (&lt;code&gt;htop&lt;/code&gt; in this case). To remember the word, I split it like this: &lt;code&gt;nix-p-k-gs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, I've made a flake package, hosted on github, and you can search what is offering, by specifying the "repository" only (no &lt;code&gt;#&lt;/code&gt;):&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix search 'github:woile/wpa_passphrase_rs'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also search packages on &lt;a href="https://search.nixos.org/packages?channel=22.11&amp;amp;show=htop&amp;amp;from=0&amp;amp;size=50&amp;amp;sort=relevance&amp;amp;type=packages&amp;amp;query=htop"&gt;nix search index&lt;/a&gt;, but the commands shown are for the old nix interface, using &lt;code&gt;nix-env&lt;/code&gt; or &lt;code&gt;nix-shell&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also, you can provide a regex like &lt;code&gt;firefox|chrome&lt;/code&gt;, run &lt;code&gt;nix search --help&lt;/code&gt; for more examples.&lt;/p&gt;
&lt;h3&gt;Removing packages&lt;/h3&gt;
&lt;p&gt;Now this is a bit tricky, to remove you cannot type &lt;code&gt;htop&lt;/code&gt;, you have to specify which dependency you want to clean. I think this is because one of your packages may depend on the version of another package, and if you also installed another version of the same package, then if you remove both, the original program that depends on one of them may break.&lt;/p&gt;
&lt;p&gt;The solution to this is to list the installed packages in your profile, and then remove by position of said program.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile list&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile remove 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile-remove.html"&gt;profile remove command reference&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Open a package on a shell&lt;/h3&gt;
&lt;p&gt;This can be useful to test in isolation without installing a package in your profile.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix shell nixpkgs#htop nixpkgs#gnused nixpkgs#youtube-dl

sed --help
htop --help
youtube-dl --version
CTRL+D # exit&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Nix package manager (npt)&lt;/h3&gt;
&lt;p&gt;Because I'm not used to most of the seen commands, I built a thin abstraction on top called &lt;a href="https://github.com/woile/npt"&gt;npt&lt;/a&gt;. Which aims to be a humble succesor to &lt;code&gt;apt&lt;/code&gt;. It also requires less characters to use it.&lt;/p&gt;
&lt;p&gt;The installation, as we've seen before, can be done by running:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile install 'github:woile/npt#npt'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then run &lt;code&gt;npt --help&lt;/code&gt; and check the commands, I hope it helps the transition to nix.&lt;/p&gt;
&lt;p&gt;Now you can install packages by doing:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;npt install htop github:woile/wpa_passphrase_rs#wpa_passphrase
# or npt i&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's still a work in progress, but a good start. I want to add to it the ability to show the executed nix commands, as a way to learn.&lt;/p&gt;
&lt;h3&gt;Reproducible scripts&lt;/h3&gt;
&lt;p&gt;Remember when I said even if you don't know much, someone else might, and having nix helps for this? and remember when I talked about my problems with &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Turns out nix can help in both of these situations, someone can write a reproducible shell script which you would execute, even without knowing much, it would work.&lt;/p&gt;
&lt;p&gt;A minor problem is that we cannot use flakes yet, meaning we cannot run &lt;code&gt;nix shell&lt;/code&gt; and instead, we have to rely on &lt;code&gt;nix-shell&lt;/code&gt;. But it's coming, see &lt;a href="https://github.com/NixOS/nix/pull/5189"&gt;#5189&lt;/a&gt;, &lt;a href="https://github.com/NixOS/nix/issues/4715"&gt;#4715&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the meantime, let's try to solve the issue with what we have.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;touch gnu-example.sh
chmod +x gnu-example.sh
vim gnu-example.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And paste the content of this script:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;#! /usr/bin/env nix-shell
#! nix-shell gnused gnugrep

grep -V
sed --version&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If run &lt;code&gt;./gnu-example.sh&lt;/code&gt;, it would work both on linux, mac and probably also on freebsd.&lt;/p&gt;
&lt;p&gt;Take a look at this other example, you can install a specific version of python and even dependencies.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-python"&gt;#! /usr/bin/env nix-shell
#! nix-shell --pure -i python -p "python38.withPackages (ps: [ ps.django ])"

import django
print(django.__version__)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This opens the door to replace &lt;code&gt;pyenv&lt;/code&gt; and any &lt;code&gt;virtualenv&lt;/code&gt; you will ever need.&lt;/p&gt;
&lt;p&gt;Imagine creating a nix file specific to your project with its dependencies, that you load only when in the project folder. Say goodbye any version manager (&lt;code&gt;pyenv&lt;/code&gt;, &lt;code&gt;nvm&lt;/code&gt;, etc).&lt;/p&gt;
&lt;p&gt;You can read more about building a &lt;code&gt;shell.nix&lt;/code&gt; in the &lt;a href="https://nix.dev/tutorials/declarative-and-reproducible-developer-environments"&gt;nix.dev tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I hope you've learned something with this post, and if you liked it, please let me know in the comments section below or tag me on hachyderm &lt;a href="https://hachyderm.io/@woile"&gt;@woile&lt;/a&gt;.&lt;/p&gt;</description><category>apt</category><category>brew</category><category>flake</category><category>nix</category><category>package manager</category><category>rust</category><guid>https://woile.dev/posts/nix-journey-part-2-replacing-apt-and-brew/</guid><pubDate>Sun, 08 Jan 2023 14:34:49 GMT</pubDate></item></channel></rss>