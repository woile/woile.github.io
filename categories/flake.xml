<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Willy's blog (Posts about flake)</title><link>https://woile.dev/</link><description></description><atom:link href="https://woile.dev/categories/flake.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2023 &lt;a href="mailto:santiwilly@gmail.com"&gt;Woile&lt;/a&gt; </copyright><lastBuildDate>Mon, 17 Apr 2023 13:43:19 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Nix journey part 3: learning nix-lang</title><link>https://woile.dev/posts/nix-journey-part-3-learning-nix-lang/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;I started reading the &lt;a href="https://nix.dev/tutorials/nix-language"&gt;nix-language&lt;/a&gt; tutorial that helps you understand the &lt;a href="https://nixos.org/manual/nix/stable/language/index.html"&gt;nix-lang&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The explanation that has made more sense so far is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you are familiar with JSON, imagine the Nix language as &lt;em&gt;JSON with functions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Nix language data types &lt;em&gt;without functions&lt;/em&gt; work just like their counterparts in JSON and look very similar.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And here's a comparison:&lt;/p&gt;
&lt;p&gt;nix:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-nix"&gt;{
  string = "hello";
  integer = 1;
  float = 3.141;
  bool = true;
  null = null;
  list = [ 1 "two" false ];
  attribute-set = {
    a = "hello";
    b = 2;
    c = 2.718;
    d = false;
  }; # comments are supported
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;json:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-json"&gt;{
  "string": "hello",
  "integer": 1,
  "float": 3.141,
  "bool": true,
  "null": null,
  "list": [1, "two", false],
  "object": {
    "a": "hello",
    "b": 1,
    "c": 2.718,
    "d": false
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I like what I see. Why not making it more similar to json though?&lt;/p&gt;
&lt;p&gt;Here I'm listing my thoughts while reading. I hope this feedback can help improve the docs (I can't yet as I literally know nothing, taking it as a brain dump):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Why no comma separated arrays? My hand automatically tries to add commas when making a list. Maybe an explanation would help to avoid people's complaints like me.&lt;/li&gt;
&lt;li&gt;JSON with comments + functions? Sounds like a plan&lt;/li&gt;
&lt;li&gt;Pure language, meaning no interaction with the outside world, except when reading files. I like this&lt;ol&gt;
&lt;li&gt;Does it mean there's no &lt;code&gt;print&lt;/code&gt;? is the output of executing nix a &lt;code&gt;print&lt;/code&gt;?&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;I bet I'll have to learn some builtin functions to understand it better&lt;/li&gt;
&lt;li&gt;String concatenation is straightforward, nothing weird here &lt;code&gt;"a" + " " + "b"&lt;/code&gt; works as expected. Good.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let .. in ...&lt;/code&gt; is weird, are they like function declarations? Strange way to create a local scope.&lt;/li&gt;
&lt;li&gt;semicolons &lt;code&gt;;&lt;/code&gt; only  after initializing variables.&lt;/li&gt;
&lt;li&gt;Could this language be used to replace &lt;code&gt;yaml&lt;/code&gt; and other configuration formats? What about &lt;code&gt;toml&lt;/code&gt; with functions? Okay, I'm derailing, back to reading.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It's not very intuitive, let's see some valid samples
&lt;/p&gt;&lt;pre class="highlight"&gt;&lt;code class="language-nix"&gt;let
  a = {
    x = 1;
    y = 2;
    z = 3;
  };
in
a.x + a.y&lt;/code&gt;&lt;/pre&gt;
it doesn't end with semicolon, outputs: 3. Ok
Now the &lt;code&gt;with&lt;/code&gt; + assignment
&lt;pre class="highlight"&gt;&lt;code class="language-nix"&gt;let
  a = {
    x = 1;
    y = 2;
    z = 3;
  };
in
b = with a; {t = x; u = y;}&lt;/code&gt;&lt;/pre&gt;
error. Solution? wrap with &lt;code&gt;{}&lt;/code&gt; and introduce semicolon
&lt;pre class="highlight"&gt;&lt;code class="language-nix"&gt;let
  a = {
    x = 1;
    y = 2;
    z = 3;
  };
in {
  b = with a; {t = x; u = y;};
}&lt;/code&gt;&lt;/pre&gt;
Works. Whatever. How do I add &lt;code&gt;b.x&lt;/code&gt; + &lt;code&gt;b.y&lt;/code&gt;?
&lt;pre class="highlight"&gt;&lt;code class="language-nix"&gt;let
  a = {
    x = 1;
    y = 2;
    z = 3;
  };
in {
  b = with a; {t = x; u = y;};
  b.t + b.u
}&lt;/code&gt;&lt;/pre&gt;
Nope, maybe the &lt;code&gt;let.. in...&lt;/code&gt; I just learned?
&lt;pre class="highlight"&gt;&lt;code class="language-nix"&gt;let
  a = {
    x = 1;
    y = 2;
    z = 3;
  };
in {
  let b = with a; {t = x; u = y;};
  in
  b.t + b.u
}&lt;/code&gt;&lt;/pre&gt;
Nope. Couldn't find an explanation, maybe it's not allowed.
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: user &lt;a href="https://www.reddit.com/user/benide/"&gt;benide&lt;/a&gt; on &lt;a href="https://www.reddit.com/r/Nix/comments/10bp1vw/nix_journey_part_3_learning_nixlang/"&gt;/r/nix&lt;/a&gt; pointed out that my scoped curly braces &lt;code&gt;{}&lt;/code&gt; are actually attrsets (json object), that's why the semi-colons &lt;code&gt;;&lt;/code&gt; are required, makes much more sense.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Why cannot coerce an int into a string? I don't see an explanation. Types could implement like a &lt;code&gt;Into&amp;lt;string&amp;gt;&lt;/code&gt; trait, right? Maybe there's a good reason, but I think this can be useful for naming things &lt;code&gt;[ home-1 home-2 ]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Integration with fs is dope.&lt;/li&gt;
&lt;li&gt;How are search path populated? &lt;code&gt;&amp;lt;nixpkgs&amp;gt;&lt;/code&gt; works, but &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; does not. Are there other variables? Good thing it's not recommended to use them.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Indented strings&lt;/code&gt; are fantastic. The equal amount of space trimmed is perfect for writing scripts that look good, without compromising style.
&lt;pre class="highlight"&gt;&lt;code class="language-nix"&gt;let
  uglyyaml = ''
  holis:
    machines:
      - m1
      - m2
  '';
in
  uglyyaml&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Well I'm done, it was worthy. After reading the quick overview I understand much more. So much I was able to create my own shell from a flake. This is the sample &lt;code&gt;flake.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-nix"&gt;/*
  This flake provides a shell where you can add flakes

  Adding dependencies:
    1. Add your flake repository as an input url
    2. Add the repository name to the function signature
    3. Add your repo's package to buildInputs

  Opening shell with your deps:
    ```sh
    nix develop
    ```

  For compatibility with nix-shell add the template compat:
    ```sh
    nix flake new . -t templates#compat
    ```
*/
{
  description = "Build your own shell";
  inputs = {
    utils = { url = "github:numtide/flake-utils"; };
    wpa_passphrase_rs = { url = "github:woile/wpa_passphrase_rs/main"; };
    # point 1: add repo url
  };
  # point 2: add to function
  outputs = { self, nixpkgs, utils, wpa_passphrase_rs }:
    utils.lib.eachDefaultSystem (system:
      let
        pkgs = import nixpkgs { inherit system; };
      in
      {
        devShell = with pkgs; mkShell {
          # point 3: add package
          buildInputs = [
            gnugrep
            gnused
            wpa_passphrase_rs.defaultPackage.${system}
          ];
        };
      }
    );
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run &lt;code&gt;nix-develop&lt;/code&gt; and you'll have a shell with your dependencies.
Question: How do I keep using my own shell?&lt;/p&gt;
&lt;p&gt;You can copy-paste and extend that sample into your projects. I asked on github if it could be merged &lt;a href="https://github.com/NixOS/templates/issues/59"&gt;#59&lt;/a&gt;. Again, as a newbie in nix I don't know if it makes sense from nix perspective. Am I supposed to be doing things this way in nix?&lt;/p&gt;
&lt;p&gt;What I've been thinking is that I would like a &lt;code&gt;cli&lt;/code&gt; that adds the code for me to the &lt;code&gt;flake.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;$ flakectl add dep github:woile/wpa_passphrase_rs
Searching packages...
1. packages.x86_64-darwin.wpa_passphrase (0.1.0)

Choose package to add [int]:
1

Does the package provide a service? [y/N]
n&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to add more things:&lt;/p&gt;
&lt;p&gt;Environmental variables (maybe even encrypted using &lt;a href="https://github.com/ryantm/agenix"&gt;agenix&lt;/a&gt;):
&lt;/p&gt;&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;$ flakectl add env SRC_FOLDER=foobar
Adding variables to your flake.nix...

After running `nix develop` or `nix-shell` to see your variable run:
`echo $SRC_FOLDER`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Language support&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;$ flakectl add lang python rust
Adding support for python and rust to your flake.nix...

Use `nix build py` to create a python wheel
Use `nix build rs` to compile the rust code.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Commands&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;$ flakectl add script deploy --bang py
Adding `deploy` script to your flake.nix...

Use `nix run deploy` to execute the script.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Would something like this make sense as output?&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;$ tree scripts
scripts/
└── deploy.nix&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And maybe some other ways to manipulate the flake itself. This way I can "ask" for the things I want, and later take a look at the result of the flake itself, without having to know much of nix-lang, and learning on the way.&lt;/p&gt;
&lt;p&gt;The question is: What are common things people need?&lt;/p&gt;
&lt;p&gt;It could be done with rust implementation of the AST parser &lt;a href="https://github.com/nix-community/rnix-parser"&gt;rnix-parser&lt;/a&gt;. Unfortunately I don't have much time to dig into this idea. Let me know if you do!&lt;/p&gt;
&lt;p&gt;Thanks for reading again.&lt;/p&gt;
&lt;p&gt;Find me on &lt;a href="https://hachyderm.io/@woile"&gt;@woile@hachyderm&lt;/a&gt;&lt;/p&gt;</description><category>flake</category><category>nix</category><category>nix-lang</category><guid>https://woile.dev/posts/nix-journey-part-3-learning-nix-lang/</guid><pubDate>Sat, 14 Jan 2023 13:26:08 GMT</pubDate></item><item><title>Nix journey part 2: replacing apt and brew</title><link>https://woile.dev/posts/nix-journey-part-2-replacing-apt-and-brew/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;Even if I still cannot do much with &lt;a href="https://nixos.org/"&gt;nix&lt;/a&gt;, it still provides more advantages over other package managers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multi-platform (mac, linux, etc.)&lt;/li&gt;
&lt;li&gt;Supports side-by-side installation of multiple versions of a package&lt;/li&gt;
&lt;li&gt;Makes it trivial to share development and build environments&lt;/li&gt;
&lt;li&gt;Nix ensures that installing or upgrading one package cannot break other packages&lt;/li&gt;
&lt;li&gt;It has the biggest database of packages (over 80.000 packages)&lt;/li&gt;
&lt;li&gt;I can run other people's commands, for example if I clone a repo and it says "run this nix command to have a development environment", then it doesn't matter if I don't know, I have already started using it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A common situation I often run into, is writing shell scripts for linux and mac, where &lt;code&gt;grip&lt;/code&gt; or &lt;code&gt;sed&lt;/code&gt; are used.
On linux, they are called GNU &lt;code&gt;grep&lt;/code&gt; or GNU &lt;code&gt;sed&lt;/code&gt;, and they are not the same as in mac (freebsd version). Depending on the version, they may use different arguments.&lt;/p&gt;
&lt;p&gt;We are going to see how can we avoid this by using &lt;code&gt;nix&lt;/code&gt;. Even without using complicated features, it can make your CI system more reproducible.&lt;/p&gt;
&lt;p&gt;Remember, &lt;code&gt;nix&lt;/code&gt; is 3 things at the same time: an OS, a package manager and a language.&lt;/p&gt;
&lt;p&gt;This post is about the &lt;strong&gt;package manager&lt;/strong&gt;. I don't have much interest in the language, yet. Though more and more, I think I'll have to learn it.&lt;/p&gt;
&lt;p&gt;Let's start by acknowledging a source of confusion:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There is an old interface with counterintuitive commands&lt;/strong&gt; (&lt;code&gt;nix-env -iA ...&lt;/code&gt;, &lt;code&gt;nix-shell -p ...&lt;/code&gt;), which I found hard to remember, and I don't get why the "commands" start with a dash (&lt;code&gt;-&lt;/code&gt;). I'm used to cli's doing &lt;code&gt;cli &amp;lt;command&amp;gt; [--options]&lt;/code&gt;. Nowadays, there's a new cli called just &lt;code&gt;nix&lt;/code&gt;. Let's see if we can do everything with it.&lt;/p&gt;
&lt;p&gt;And make sure you have &lt;a href="https://nixos.org/download.html"&gt;installed Nix: the package manager&lt;/a&gt; in your system. The installation is straightforward. I was personally blocked, because at some point in my dotfiles I was hardcoding the &lt;code&gt;PATH&lt;/code&gt;, making nix never appear 🤦‍♂️.&lt;/p&gt;
&lt;p&gt;And &lt;a href="https://nixos.wiki/wiki/Flakes#Enable_flakes"&gt;enable flakes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There's also a &lt;a href="https://github.com/DeterminateSystems/nix-installer"&gt;new installer by determine systems&lt;/a&gt;, which is quite good.&lt;/p&gt;
&lt;h3&gt;Installing packages&lt;/h3&gt;
&lt;p&gt;Install a package like on &lt;code&gt;brew&lt;/code&gt; or &lt;code&gt;apt&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile install nixpkgs#htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See also the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile-install.html"&gt;profile install command reference&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the old version of nix, we would run:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix-env -iA nixpkgs.htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nix forces us to specify a "repository" (or "namespace") when installing a package (&lt;code&gt;nixpkgs&lt;/code&gt;), which could be different, like github. And I think this is a good thing. From my understanding, nix doesn't care where the package is, because each package has a lock file, tracking all the dependencies. Okay, it could be a problem if one of the "repositories" is down, but using &lt;code&gt;nixpkgs&lt;/code&gt; mainly and github for niche packages should be fine.&lt;/p&gt;
&lt;h4&gt;What are profiles?&lt;/h4&gt;
&lt;p&gt;Disclaimer: I may be wrong on this, I'm starting to understand it.&lt;/p&gt;
&lt;p&gt;The way to see &lt;code&gt;profiles&lt;/code&gt; is like, "your user's packages". &lt;code&gt;nix profile&lt;/code&gt; links packages to your &lt;code&gt;~/.nix-profile/&lt;/code&gt;. You can specify other's profiles by using the flag &lt;code&gt;-p&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can find more in the &lt;a href="https://nixos.org/manual/nix/stable/package-management/profiles.html"&gt;package-management section of the manual&lt;/a&gt; and &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile.html"&gt;the profile command reference&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Searching packages&lt;/h3&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix search nixpkgs#htop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-search.html"&gt;search command reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We see again &lt;code&gt;nixpkgs&lt;/code&gt;, because we have to let nix know from where, and then what we are looking for (&lt;code&gt;htop&lt;/code&gt; in this case). To remember the word, I split it like this: &lt;code&gt;nix-p-k-gs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, I've made a flake package, hosted on github, and you can search what is offering, by specifying the "repository" only (no &lt;code&gt;#&lt;/code&gt;):&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix search 'github:woile/wpa_passphrase_rs'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also search packages on &lt;a href="https://search.nixos.org/packages?channel=22.11&amp;amp;show=htop&amp;amp;from=0&amp;amp;size=50&amp;amp;sort=relevance&amp;amp;type=packages&amp;amp;query=htop"&gt;nix search index&lt;/a&gt;, but the commands shown are for the old nix interface, using &lt;code&gt;nix-env&lt;/code&gt; or &lt;code&gt;nix-shell&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also, you can provide a regex like &lt;code&gt;firefox|chrome&lt;/code&gt;, run &lt;code&gt;nix search --help&lt;/code&gt; for more examples.&lt;/p&gt;
&lt;h3&gt;Removing packages&lt;/h3&gt;
&lt;p&gt;Now this is a bit tricky, to remove you cannot type &lt;code&gt;htop&lt;/code&gt;, you have to specify which dependency you want to clean. I think this is because you can have multiple versions of the same program. Also, one of your packages may depend on the version of another package, and if you also installed another version of the same package, and if you remove both, the original program that depends on one of them may break.&lt;/p&gt;
&lt;p&gt;The solution to this is to list the installed packages in your profile, and then remove by position of said program.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile list&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile remove 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the &lt;a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-profile-remove.html"&gt;profile remove command reference&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Open a package on a shell&lt;/h3&gt;
&lt;p&gt;This can be useful to test in isolation without installing a package in your profile.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix shell nixpkgs#htop nixpkgs#gnused nixpkgs#youtube-dl

sed --help
htop --help
youtube-dl --version
CTRL+D # exit&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Nix Package Tool (npt)&lt;/h3&gt;
&lt;p&gt;Because I'm not used to most of the seen commands, I built a thin abstraction on top of &lt;code&gt;nix&lt;/code&gt; called &lt;a href="https://github.com/woile/npt"&gt;npt&lt;/a&gt;. Which aims to be a humble succesor to &lt;code&gt;apt&lt;/code&gt;. It also requires less characters to use it.&lt;/p&gt;
&lt;p&gt;The installation, as we've seen before, can be done by running:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix profile install 'github:woile/npt#npt'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then run &lt;code&gt;npt --help&lt;/code&gt; and check the commands, I hope it helps the transition to nix.&lt;/p&gt;
&lt;p&gt;Now you can install packages by doing:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;npt install htop github:woile/wpa_passphrase_rs#wpa_passphrase
# or npt i&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's still a work in progress, but a good start. I want to add the ability to show the executed nix commands, as a way of learning nix.&lt;/p&gt;
&lt;h3&gt;Reproducible scripts&lt;/h3&gt;
&lt;p&gt;Remember when I said "even if you don't know much, someone else might", and having nix helps for this? and remember when I talked about my problems with &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Turns out, nix can help in both of these situations, someone can write a reproducible shell script which you would execute, and even without knowing much, it would work.&lt;/p&gt;
&lt;p&gt;A minor problem is that we cannot use flakes yet, meaning we cannot run &lt;code&gt;nix shell&lt;/code&gt; and instead, we have to rely on &lt;code&gt;nix-shell&lt;/code&gt;. But it's coming, see &lt;a href="https://github.com/NixOS/nix/pull/5189"&gt;#5189&lt;/a&gt;, &lt;a href="https://github.com/NixOS/nix/issues/4715"&gt;#4715&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the meantime, let's try to solve the issue with what we have.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;touch gnu-example.sh
chmod +x gnu-example.sh
vim gnu-example.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And paste the content of this script:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;#! /usr/bin/env nix-shell
#! nix-shell gnused gnugrep

grep -V
sed --version&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If run &lt;code&gt;./gnu-example.sh&lt;/code&gt;, it would work both on linux, mac and probably also on freebsd.&lt;/p&gt;
&lt;p&gt;Take a look at this other example, you can install a specific version of python and even dependencies.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-python"&gt;#! /usr/bin/env nix-shell
#! nix-shell --pure -i python -p "python38.withPackages (ps: [ ps.django ])"

import django
print(django.__version__)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This opens the door to replace &lt;code&gt;pyenv&lt;/code&gt; and any &lt;code&gt;virtualenv&lt;/code&gt; you will ever need.&lt;/p&gt;
&lt;p&gt;Imagine creating a nix file specific to your project with its dependencies, which loads a shell with the dependencies when you navigate to the project folder automatically. Yes, you can say goodbye to any version manager (&lt;code&gt;pyenv&lt;/code&gt;, &lt;code&gt;nvm&lt;/code&gt;, etc).&lt;/p&gt;
&lt;p&gt;You can read more about building a &lt;code&gt;shell.nix&lt;/code&gt; in the &lt;a href="https://nix.dev/tutorials/declarative-and-reproducible-developer-environments"&gt;nix.dev tutorial&lt;/a&gt;. But keep in mind that &lt;code&gt;shell.nix&lt;/code&gt; is being replaced by flakes.&lt;/p&gt;
&lt;h3&gt;Flakes&lt;/h3&gt;
&lt;p&gt;Flakes are becoming the universal way of doing things in nix. &lt;a href="https://github.com/woile/wpa_passphrase_rs/blob/main/flake.nix#L19-L22"&gt;Creating shells&lt;/a&gt;, build commands, &lt;a href="https://github.com/woile/wpa_passphrase_rs/blob/main/flake.nix#L17"&gt;compiling your source code&lt;/a&gt; or &lt;a href="https://github.com/woile/rpi-iso-flake/blob/main/flake.nix#L22"&gt;creating ISO images&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And there's a whole set of new tools making use of flakes that allow you to build dev shells, like &lt;a href="https://github.com/cachix/devenv"&gt;devenv&lt;/a&gt; or &lt;a href="https://github.com/flox/flox"&gt;flox&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;An exciting future is ahead!&lt;/p&gt;
&lt;p&gt;I hope you've learned something with this post, and if you liked it, please let me know in the comments section below or tag me on hachyderm &lt;a href="https://hachyderm.io/@woile"&gt;@woile&lt;/a&gt;.&lt;/p&gt;</description><category>apt</category><category>brew</category><category>flake</category><category>nix</category><category>package manager</category><category>rust</category><guid>https://woile.dev/posts/nix-journey-part-2-replacing-apt-and-brew/</guid><pubDate>Sun, 08 Jan 2023 14:34:49 GMT</pubDate></item><item><title>Nix journey part 1: creating a flake</title><link>https://woile.dev/posts/nix-journey-part-1-creating-a-flake/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;I've started building my own home media center, and I thought it would be a good idea to learn something new and try to make it reproducible, thus I thought of &lt;a href="https://nixos.org/"&gt;nix&lt;/a&gt; for this. Nix is an operating system (which we won't care now), a language (also don't care for now), and a &lt;strong&gt;package manager&lt;/strong&gt;.
We are gonna focus on the package manager part alone, which is already a lot for my brain. This package manager works on mac and linux, and it already has many packages available (bye bye interop problems between mac/linux?)&lt;/p&gt;
&lt;p&gt;The first thing I needed for my raspberry pi was to create a PSK password using &lt;code&gt;wpa_password&lt;/code&gt;, and I tried to run it inside a nix shell on my mac, which didn't work, because &lt;code&gt;wpa_password&lt;/code&gt; doesn't run on a mac.
This was a good opportunity to write something fast, and to make it reusable and reproducible from any unix OS using nix.&lt;/p&gt;
&lt;h3&gt;Objectives&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Create a nix package for &lt;code&gt;wpa_password&lt;/code&gt; (a nix flake)&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;wpa_password&lt;/code&gt; in my home-media project. I want to jump into a shell with the &lt;code&gt;wpa_password&lt;/code&gt; from any unix os, mac or linux (freebsd at some point?)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Creating a nix package&lt;/h3&gt;
&lt;p&gt;I ended up writing the utility in rust, which took me a bunch of hours, the repo &lt;a href="https://github.com/woile/wpa_passphrase_rs"&gt;wpa_passphrase_rs&lt;/a&gt; contains the project finalized.&lt;/p&gt;
&lt;p&gt;After a lot of reading, and wrapping my mind around nix, which I had 0 knowledge before, everything points out that flakes are the new kid in town, and that's what I should use in my project.&lt;/p&gt;
&lt;p&gt;I have a take on nix status, which may need corroboration: nix is moving away from the old way to the new (flakes) way, and there are many outdated posts, and commands. Many commands that fit the pattern &lt;code&gt;nix-*&lt;/code&gt; are no longer used, and instead people now use the new &lt;code&gt;nix &amp;lt;command&amp;gt;&lt;/code&gt; instead. For example, things like &lt;code&gt;nix-shell&lt;/code&gt; are not used much anymore.&lt;/p&gt;
&lt;p&gt;Going back to the nix flake, If you have &lt;a href="https://nixos.org/download.html"&gt;installed nix&lt;/a&gt;, &lt;strong&gt;flakes must be enabled&lt;/strong&gt;, because it's an experimental feature.&lt;/p&gt;
&lt;p&gt;For mac (which only supports multiuser installation):&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;echo 'experimental-features = nix-command flakes' &amp;gt;&amp;gt; /etc/nix/nix.conf
# you may use ~/.config/nix/nix.conf on linux&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;What are flakes?&lt;/h4&gt;
&lt;p&gt;According to &lt;a href="https://nixos.wiki/wiki/Flakes"&gt;nix's wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flakes allow you to specify your code's dependencies (e.g. remote Git repositories) in a &lt;strong&gt;declarative way&lt;/strong&gt;, simply by listing them inside a &lt;code&gt;flake.nix&lt;/code&gt; file.
Each dependency gets pinned, that is: its commit hash gets automatically stored into a file - named &lt;code&gt;flake.lock&lt;/code&gt; - making it easy to, upgrade it
Flakes replace the nix-channels command and things like ad-hoc invocations of &lt;code&gt;builtins.fetchgit&lt;/code&gt; - no more worrying about keeping your channels in sync, no more worrying about forgetting about a dependency deep down in your tree: everything's at hand right inside &lt;code&gt;flake.lock&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Seems like we are gonna need two files: &lt;code&gt;flake.nix&lt;/code&gt; and &lt;code&gt;flake.lock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The next step is to create the flake from a template. What available templates do we have? I wonder...&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix flake show templates&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;github:NixOS/templates/2d6dcce2f3898090c8eda16a16abdff8a80e8ebf
├───defaultTemplate: template: A very basic flake
└───templates
    ├───bash-hello: template: An over-engineered Hello World in bash
    ├───c-hello: template: An over-engineered Hello World in C
    ├───compat: template: A default.nix and shell.nix for backward compatibility with Nix installations that don't support flakes
    ├───full: template: A template that shows all standard flake outputs
    ├───go-hello: template: A simple Go package
    ├───haskell-hello: template: A Hello World in Haskell with one dependency
    ├───haskell-nix: template: An haskell.nix template using hix
    ├───hercules-ci: template: An example for Hercules-CI, containing only the necessary attributes for adding to your project.
    ├───pandoc-xelatex: template: A report built with Pandoc, XeLaTex and a custom font
    ├───python: template: Python template, using poetry2nix
    ├───rust: template: Rust template, using Naersk
    ├───rust-web-server: template: A Rust web server including a NixOS module
    ├───simpleContainer: template: A NixOS container running apache-httpd
    └───trivial: template: A very basic flake&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fantastic! Look at that! There's a python version and even a rust web server. The one I need is the rust template, let's use that one as a base.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix flake init -t templates#rust&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that was it, it worked. This is going well. I can create a binary inside &lt;code&gt;./result/bin&lt;/code&gt; by running&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix build&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or use it by running&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix run&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;My mind is blown at this point 🤯&lt;/p&gt;
&lt;h3&gt;Using the flake somewhere else&lt;/h3&gt;
&lt;p&gt;I couldn't find much about this, as I said, there's a mix of old and new information.
I think it clicked for me, when I realized that the &lt;code&gt;nix&lt;/code&gt; command is new, and it's integration with flakes goes to its core (am I correct on this?).&lt;/p&gt;
&lt;p&gt;Using the flake becomes straightforward.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;nix shell 'github:woile/wpa_passphrase_rs'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And &lt;code&gt;wpa_password&lt;/code&gt; will appear on my &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-sh"&gt;wpa_password --help&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can exit with a &lt;kbd&gt;CTRL&lt;/kbd&gt; + &lt;kbd&gt;D&lt;/kbd&gt;.&lt;/p&gt;
&lt;h3&gt;What's next?&lt;/h3&gt;
&lt;p&gt;What's the right way to make it declarative? I want to have a file with the dependencies required for my home media project, and I'd like to jump into a shell with everything present.&lt;/p&gt;
&lt;p&gt;Is there a different strategy for this?&lt;/p&gt;
&lt;p&gt;How to use &lt;a href="https://github.com/NixOS/nixops"&gt;NixOps&lt;/a&gt; to provision all my raspberries and any other machine that joins the fleet?&lt;/p&gt;
&lt;p&gt;This &lt;a href="https://nixos.wiki/wiki/Ubuntu_vs._NixOS"&gt;comparison between Ubuntu and Nix&lt;/a&gt; appears to be useful, I should read as well.&lt;/p&gt;
&lt;p&gt;Please let me know in the comments section below or tag me on hachyderm &lt;a href="https://hachyderm.io/@woile"&gt;@woile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thanks for reading&lt;/p&gt;</description><category>flake</category><category>nix</category><category>package manager</category><category>rust</category><guid>https://woile.dev/posts/nix-journey-part-1-creating-a-flake/</guid><pubDate>Fri, 30 Dec 2022 16:04:18 GMT</pubDate></item></channel></rss>