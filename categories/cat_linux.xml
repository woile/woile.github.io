<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Willy's blog (Posts about linux)</title><link>https://woile.dev/</link><description></description><atom:link href="https://woile.dev/categories/cat_linux.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents ¬© 2022 &lt;a href="mailto:santiwilly@gmail.com"&gt;Woile&lt;/a&gt; </copyright><lastBuildDate>Mon, 14 Mar 2022 09:29:30 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Digesting Make and Makefiles</title><link>https://woile.dev/posts/digesting-make-makefile/</link><dc:creator>Woile</dc:creator><description>&lt;p&gt;Make and its makefiles, are a fantastic tool to keep track of the commands needed to build or run an application.
I have recently done a big refactor for a project, where we make heavy use of Make, and decided to write this small piece about Make.&lt;/p&gt;
&lt;p&gt;Just create a &lt;code&gt;Makefile&lt;/code&gt; at the root of your project, start adding commands, and done... right? Not really.&lt;/p&gt;
&lt;p&gt;Let's explore a bit more what I mean, and then try to build a mental model that matches reality a bit better,
closing with some magic you can do with Makefiles.&lt;/p&gt;
&lt;p&gt;Set up a practice field by running in the terminal:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;mkdir /tmp/practice
&lt;span class="nb"&gt;cd&lt;/span&gt; /tmp/practice
touch index.html
&lt;/pre&gt;
&lt;p&gt;And write a minimal &lt;code&gt;Makefile&lt;/code&gt; with your favourite editor (E.g: &lt;code&gt;vim Makefile&lt;/code&gt;)&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist
    cp index.html dist/index.html
&lt;/pre&gt;
&lt;p&gt;Then execute in your terminal:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;make build
&lt;/pre&gt;
&lt;p&gt;This will create a folder &lt;code&gt;dist&lt;/code&gt;, and copy &lt;code&gt;index.html&lt;/code&gt; into the folder &lt;code&gt;dist&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is good. Particularly for me, it documents the commands used by the project, and helps future me.&lt;/p&gt;
&lt;p&gt;Let's refactor a bit, to show some extra functionality:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp index.html dist/index.html
&lt;/pre&gt;
&lt;p&gt;Notice the &lt;code&gt;build: dist&lt;/code&gt;, it means: call &lt;code&gt;dist&lt;/code&gt; command &lt;em&gt;before&lt;/em&gt; running &lt;code&gt;build&lt;/code&gt;&lt;/p&gt;
&lt;pre class="code literal-block"&gt;make build
&lt;/pre&gt;
&lt;p&gt;The functionality remains the same.&lt;/p&gt;
&lt;h4&gt;Recap&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;We created two commands: &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;dist&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And &lt;code&gt;dist&lt;/code&gt; is executed by the &lt;code&gt;build&lt;/code&gt; before running itself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is ok, but it's not necessary a correct mental model.
In the Makefile world, commands are not commands... but files.&lt;/p&gt;
&lt;h3&gt;New mental model&lt;/h3&gt;
&lt;p&gt;In a nutshell, make builds a &lt;a href="https://en.wikipedia.org/wiki/Dependency_graph"&gt;dependency graph&lt;/a&gt; of files and folders.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt; and &lt;code&gt;dist&lt;/code&gt; are actually &lt;strong&gt;target files&lt;/strong&gt; (or folders).&lt;/li&gt;
&lt;li&gt;doing &lt;code&gt;build: dist&lt;/code&gt; means that &lt;code&gt;build&lt;/code&gt; depends on &lt;code&gt;dist&lt;/code&gt; existing first.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we had a file called &lt;code&gt;build&lt;/code&gt; , doing &lt;code&gt;make build&lt;/code&gt;, wouldn't execute anything.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;touch build
make build
$ make: `build' is up to date.
&lt;/pre&gt;
&lt;p&gt;If we want to actually treat &lt;code&gt;build&lt;/code&gt; as a command, we have to add &lt;code&gt;.PHONY&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;
&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp index.html dist/index.html
&lt;/pre&gt;
&lt;p&gt;This way Make no longer sees &lt;code&gt;build&lt;/code&gt; as a file, but instead as a recipe, and it will be
executed everytime.&lt;/p&gt;
&lt;h3&gt;Back to targets&lt;/h3&gt;
&lt;p&gt;Remember what we said about targets and dependency graph? No? Me neither.
Don't worry, I actually didn't say anything.&lt;/p&gt;
&lt;p&gt;If you treat your targets as &lt;strong&gt;files&lt;/strong&gt;, Make can keep track of the files that have
changed, and update only those.&lt;/p&gt;
&lt;p&gt;By knowing this our previous example could be refactored into:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;dist/index.html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp index.html dist/index.html
&lt;/pre&gt;
&lt;p&gt;And now we tell Make to create our target file:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;make dist/index.html
&lt;/pre&gt;
&lt;p&gt;If we run multiple times, we get:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;make: `dist/index.html' is up to date.
&lt;/pre&gt;
&lt;p&gt;We would expect that by modifying &lt;code&gt;index.html&lt;/code&gt;, and running &lt;code&gt;make dist/index.html&lt;/code&gt;, it would be rebuilt,
but we are getting the same message.&lt;/p&gt;
&lt;h3&gt;Dependencies&lt;/h3&gt;
&lt;p&gt;We need to tell Make that it depends on another file: &lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;dist/index.html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt;
    cp index.html dist/index.html
&lt;/pre&gt;
&lt;p&gt;This time, if &lt;code&gt;index.html&lt;/code&gt; is modified, &lt;code&gt;make dist/index.html&lt;/code&gt; will run again.
Thus, when dependecies are updated, &lt;strong&gt;target files&lt;/strong&gt; are recreated.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Makefile targets and dependencies" src="https://woile.dev/images/makefile/make-targets-deps.png"&gt;&lt;/p&gt;
&lt;h3&gt;Patterns&lt;/h3&gt;
&lt;p&gt;Now let's say we have many html files&lt;/p&gt;
&lt;pre class="code literal-block"&gt;touch about.html privacy.html docs.html
&lt;/pre&gt;
&lt;p&gt;And we want to do the same for all the files, without creating many commands in Make.
For this case we use a pattern (&lt;code&gt;%&lt;/code&gt;), and some Make variables:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt;: the target file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt;: the input file&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;dist/%.html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; %.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp $&amp;lt; &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="code literal-block"&gt;make dist/about.html
&lt;/pre&gt;
&lt;p&gt;And we would be explicitly telling Make which file to create.&lt;/p&gt;
&lt;p&gt;But what if we want to copy all the files at the same time?&lt;/p&gt;
&lt;p&gt;Our current implementation, doesn't know about the available files.
And we are providing the &lt;code&gt;about&lt;/code&gt; to the &lt;code&gt;make dist/about.html&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We have to find a way to "know" all the possible targets.&lt;/p&gt;
&lt;h3&gt;Variables&lt;/h3&gt;
&lt;p&gt;We are gonna find the source files (&lt;code&gt;*.html&lt;/code&gt; files which are not in the &lt;code&gt;dist&lt;/code&gt; folder), store in a variable,
and then use that information to create the target html files.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;SRC_HTMLS&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;shell find . -name &lt;span class="s1"&gt;'*.html'&lt;/span&gt; -depth &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;TARGET_HTMLS&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;SRC_HTMLS:./%.html&lt;span class="o"&gt;=&lt;/span&gt;dist/%.html&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;
&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;TARGET_HTMLS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;$(&lt;/span&gt;info Done&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    mkdir dist

&lt;span class="nf"&gt;dist/%.html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; %.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
    cp $&amp;lt; &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="code literal-block"&gt;make build
&lt;/pre&gt;
&lt;p&gt;What happens is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt; has all the &lt;code&gt;TARGET_HTMLS&lt;/code&gt; files as dependency&lt;/li&gt;
&lt;li&gt;Make also sees &lt;code&gt;dist/%.html&lt;/code&gt; and the pattern will fit the criteria for each &lt;code&gt;TARGET_HTMLS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;dist/%.html&lt;/code&gt; we have as dependency  the &lt;code&gt;%.html&lt;/code&gt;, so Make takes the pattern and checks if a &lt;code&gt;%.html&lt;/code&gt; file exist&lt;/li&gt;
&lt;li&gt;If the conditions are met, it runs the &lt;code&gt;cp&lt;/code&gt; command for each file, unless they are already present and not updated&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can think of&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;TARGET_HTMLS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;As&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;/&lt;span class="n"&gt;index&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;/&lt;span class="n"&gt;about&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;/&lt;span class="n"&gt;docs&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;/&lt;span class="n"&gt;privacy&lt;/span&gt;.&lt;span class="n"&gt;html&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Variables can be reference using &lt;code&gt;$()&lt;/code&gt; or &lt;code&gt;${}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We also use &lt;code&gt;$(info Done)&lt;/code&gt; to send information messages to the user.
Make also provides &lt;code&gt;$(warning text‚Ä¶)&lt;/code&gt; for warnings, and
&lt;code&gt;$(error text...)&lt;/code&gt; to exit earlier with an error code different than 0.
See &lt;a href="https://www.gnu.org/software/make/manual/html_node/Make-Control-Functions.html"&gt;Make-Control-Functions&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;One more time&lt;/h3&gt;
&lt;p&gt;Let's start over by removing the &lt;code&gt;dist&lt;/code&gt; folder, and see what happens&lt;/p&gt;
&lt;pre class="code literal-block"&gt;rm -rf dist
&lt;/pre&gt;
&lt;pre class="code literal-block"&gt;‚ùØ make build
mkdir dist
cp index.html dist/index.html
cp about.html dist/about.html
cp docs.html dist/docs.html
cp privacy.html dist/privacy.html
Done

‚ùØ make build
Done
make: Nothing to be done for `build'.
&lt;/pre&gt;
&lt;p&gt;As you can see, files that have not changed, won't be rebuilt by Make.&lt;/p&gt;
&lt;p&gt;Now, try using &lt;code&gt;touch&lt;/code&gt; on the different &lt;code&gt;html&lt;/code&gt; files and running &lt;code&gt;make build&lt;/code&gt; to see what happens.&lt;/p&gt;
&lt;h3&gt;More functionality&lt;/h3&gt;
&lt;p&gt;Make is a powerful tool, and provides much more functionality, so far with the web stack
I haven't had the need for more complexity.&lt;/p&gt;
&lt;p&gt;I usually wrap docker commands, and make use of different variables, but if the need arises,
make has extra functionality, life:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;if/conditions&lt;/li&gt;
&lt;li&gt;change the shell in which the commands are executed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.delete_on_error&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;Make is usually a good way to keep track of a project's commands, as it's available in Unix systems,
and you can be up and running fast.
But by no means is perfect, it can sometimes be hard to read, or use.
It's not available on Windows. And because it was designed for the C,C++ era, it plays well with files,
but it doesn't mean it fits perfectly the web development paradigm, where you don't "transform" files much
and where &lt;code&gt;docker&lt;/code&gt; is used a lot.&lt;/p&gt;
&lt;p&gt;So depending on your situation, there are some popular alternatives:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/casey/just"&gt;just&lt;/a&gt;: modern approach to make written in rust&lt;/li&gt;
&lt;li&gt;&lt;a href="https://earthly.dev/"&gt;earthly.dev&lt;/a&gt;: repeatable builds based on docker&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bazel.build/"&gt;bazel&lt;/a&gt;: build tool from Google&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/github/scripts-to-rule-them-all"&gt;scripts-to-rule-them-all&lt;/a&gt;: just use scripts, like &lt;a href="https://github.com/encode/starlette/tree/master/scripts"&gt;starlette&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Resources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/make/manual/html_node/"&gt;GNU Make Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://makefiletutorial.com/"&gt;Makefiletutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks for reading! üëã&lt;/p&gt;
&lt;p&gt;If you are interested in what I write, follow me on &lt;a href="https://twitter.com/santiwilly"&gt;twitter&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;</description><category>documentation</category><category>gnu</category><category>linux</category><category>make</category><category>tutorial</category><category>unix</category><guid>https://woile.dev/posts/digesting-make-makefile/</guid><pubDate>Thu, 17 Feb 2022 12:21:47 GMT</pubDate></item><item><title>Decrypt filesystem</title><link>https://woile.dev/posts/decrypt-filesystem/</link><dc:creator>Woile</dc:creator><description>&lt;div&gt;&lt;h2&gt;Decrypt ubuntu filesystem&lt;/h2&gt;
&lt;p&gt;If you have encrypted your drive with one of the latest ubuntu version, this is how to decrypt using the command line.&lt;/p&gt;
&lt;p&gt;A few weeks ago I had a problem with my ubuntu (as usual) and I had no clue how to decrypt my file, which it's encrypted by my company's policy.&lt;/p&gt;
&lt;p&gt;Optional: run a &lt;strong&gt;live ubuntu&lt;/strong&gt; if your system is not working properly&lt;/p&gt;
&lt;h3&gt;First option&lt;/h3&gt;
&lt;p&gt;Open a terminal and type &lt;code&gt;sudo ecryptfs-unwrap-passphrase&lt;/code&gt;. Most of the time this should do it.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://woile.dev/posts/decrypt-filesystem/"&gt;Read more‚Ä¶&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>encrypt</category><category>linux</category><category>ubuntu</category><guid>https://woile.dev/posts/decrypt-filesystem/</guid><pubDate>Fri, 13 Jul 2018 21:14:43 GMT</pubDate></item><item><title>Get Skype working on Debian Stretch x64 with GNOME3</title><link>https://woile.dev/posts/get-skype-working-on-debian-stretch-x64-with-gnome3/</link><dc:creator>Woile</dc:creator><description>&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;Note&lt;/p&gt;
&lt;p&gt;This info is no longer relevant. Right now Skype has been rewritten using &lt;a class="reference external" href="https://electron.atom.io/"&gt;electron&lt;/a&gt; and installing it in a debian based system is no longer a problem.
Right now it doesn't support screensharing and some other features a normal person would expect.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some alternatives I recommend:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://appear.in/"&gt;appear.in&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://tox.chat/"&gt;tox&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://hangouts.google.com/"&gt;hangouts&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://discordapp.com/"&gt;discord&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you really need to install this software, and you cannot use the alternatives, then this guide is for you.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://woile.dev/posts/get-skype-working-on-debian-stretch-x64-with-gnome3/"&gt;Read more‚Ä¶&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>debian</category><category>linux</category><category>skype</category><guid>https://woile.dev/posts/get-skype-working-on-debian-stretch-x64-with-gnome3/</guid><pubDate>Mon, 19 Sep 2016 10:56:03 GMT</pubDate></item></channel></rss>